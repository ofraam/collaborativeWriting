(iversion
Page
p1
(dp2
S'revisions'
p3
(lp4
(iversion
Version
p5
(dp6
S'date'
p7
cdatetime
datetime
p8
(S'\x07\xd5\x08\x1c\r\x009\x00\x00\x00'
tRp9
sS'text'
p10
VGraphplan is an algorithm, developed by Avrim Blum and Merrick Furst, applied to planning problems in the field of artificial intelligence.  It constructs a planning graph in order to find a sequence of events leading to a goal state.\u000a*Russell, Stuart, and Peter Norvig. Artificial Intelligence: A Modern Approach, Second Edition. Upper Saddle River, New Jersey: Prentice Hall, 2003.\u000a*[http://www.cs.cmu.edu/~avrim/graphplan.html Avrim Blum's Graphplan home page]\u000a
p11
sS'paragraphs'
p12
(lp13
(iversion
Paragraph
p14
(dp15
g10
VGraphplan is an algorithm, developed by Avrim Blum and Merrick Furst, applied to planning problems in the field of artificial intelligence.  It constructs a planning graph in order to find a sequence of events leading to a goal state.*Russell, Stuart, and Peter Norvig. Artificial Intelligence: A Modern Approach, Second Edition. Upper Saddle River, New Jersey: Prentice Hall, 2003.*[http://www.cs.cmu.edu/~avrim/graphplan.html Avrim Blum's Graphplan home page]
p16
sS'changed'
p17
I00
sS'nextindex'
p18
NsS'lastindex'
p19
NsbasS'author'
p20
VSimonP
p21
sba(iversion
Version
p22
(dp23
g7
g8
(S'\x07\xd5\n\x14\x13\x10\x1d\x00\x00\x00'
tRp24
sg10
VGraphplan is an algorithm for automated planning developed by Avrim Blum and Merrick Furst in 1995. Graphplan takes as input a planning problem expressed in Strips and produces, if any, a sequence of operations for reaching a goal state. The name graphplan is due its use of a graph as an intermediate structure to reduce the amount of search needed to find the solution.\u000a \u000aThe graph used by graphplan is not the search space graph, a graph in which possible states are nodes and edges indicate reachability. The nodes of the graph are instead conditions and actions, arranged into alternate levels of conditions and actions.\u000aThe conditions of the first levels are those initially true. The third level contains all conditions that can actually be made true at the second time point by executing some actions, etc. The odd levels contain the actions that can be perfomed at each time step. By definition, each level (of actions or conditions) can be build from the previous one (of conditions or actions, respectively).\u000a \u000aA level of action can contain two actions that can be executed in isolation but not together. As a result, the next level of conditions can contain conditions that cannot be made true at the same time because they are made true by actions that cannot all be executed at the same time. Graphplan stores incompatibility of actions and conditions at each level, and uses them to determine the incompatibilities at the next level.\u000a \u000aThe graph produced by graphplan contains all conditions that can be made true and all actions that can be executed at some time point, but can also contain other conditions and actions. The actual search for a plan can be done by backward chaining (starting from the goal and recursively establishing which subgoals have to be reached to reach the goal). The graph is used in this phase to reduce the number of possibilities the algorithm has to consider.\u000a \u000a*A. Blum and M. Furts (1997). Fast planning through planning graph analysis. Artificial intelligence. 90:281-300.\u000a*Russell, Stuart, and Peter Norvig. Artificial Intelligence: A Modern Approach, Second Edition. Upper Saddle River, New Jersey: Prentice Hall, 2003.\u000a*[http://www.cs.cmu.edu/~avrim/graphplan.html Avrim Blum's Graphplan home page]\u000a
p25
sg12
(lp26
(iversion
Paragraph
p27
(dp28
g10
VGraphplan is an algorithm for automated planning developed by Avrim Blum and Merrick Furst in 1995. Graphplan takes as input a planning problem expressed in Strips and produces, if any, a sequence of operations for reaching a goal state. The name graphplan is due its use of a graph as an intermediate structure to reduce the amount of search needed to find the solution.
p29
sg17
I00
sg18
Nsg19
Nsba(iversion
Paragraph
p30
(dp31
g10
V The graph used by graphplan is not the search space graph, a graph in which possible states are nodes and edges indicate reachability. The nodes of the graph are instead conditions and actions, arranged into alternate levels of conditions and actions.
p32
sg17
I00
sg18
Nsg19
Nsba(iversion
Paragraph
p33
(dp34
g10
VThe conditions of the first levels are those initially true. The third level contains all conditions that can actually be made true at the second time point by executing some actions, etc. The odd levels contain the actions that can be perfomed at each time step. By definition, each level (of actions or conditions) can be build from the previous one (of conditions or actions, respectively).
p35
sg17
I00
sg18
Nsg19
Nsba(iversion
Paragraph
p36
(dp37
g10
V A level of action can contain two actions that can be executed in isolation but not together. As a result, the next level of conditions can contain conditions that cannot be made true at the same time because they are made true by actions that cannot all be executed at the same time. Graphplan stores incompatibility of actions and conditions at each level, and uses them to determine the incompatibilities at the next level.
p38
sg17
I00
sg18
Nsg19
Nsba(iversion
Paragraph
p39
(dp40
g10
V The graph produced by graphplan contains all conditions that can be made true and all actions that can be executed at some time point, but can also contain other conditions and actions. The actual search for a plan can be done by backward chaining (starting from the goal and recursively establishing which subgoals have to be reached to reach the goal). The graph is used in this phase to reduce the number of possibilities the algorithm has to consider.
p41
sg17
I00
sg18
Nsg19
Nsba(iversion
Paragraph
p42
(dp43
g10
V *A. Blum and M. Furts (1997). Fast planning through planning graph analysis. Artificial intelligence. 90:281-300.*Russell, Stuart, and Peter Norvig. Artificial Intelligence: A Modern Approach, Second Edition. Upper Saddle River, New Jersey: Prentice Hall, 2003.*[http://www.cs.cmu.edu/~avrim/graphplan.html Avrim Blum's Graphplan home page]
p44
sg17
I00
sg18
Nsg19
Nsbasg20
VTizio
p45
sba(iversion
Version
p46
(dp47
g7
g8
(S'\x07\xd5\n\x15\x0c\x068\x00\x00\x00'
tRp48
sg10
VGraphplan is an algorithm for automated planning developed by Avrim Blum and Merrick Furst in 1995. Graphplan takes as input a planning problem expressed in STRIPS and produces, if any, a sequence of operations for reaching a goal state. The name graphplan is due its use of a graph as an intermediate structure to reduce the amount of search needed to find the solution.\u000a \u000aThe graph used by graphplan is not the search space graph, a graph in which possible states are nodes and edges indicate reachability. The nodes of the graph are instead conditions and actions, arranged into alternate levels of conditions and actions.\u000aThe conditions of the first levels are those initially true. The third level contains all conditions that can actually be made true at the second time point by executing some actions, etc. The odd levels contain the actions that can be perfomed at each time step. By definition, each level (of actions or conditions) can be build from the previous one (of conditions or actions, respectively).\u000a \u000aA level of action can contain two actions that can be executed in isolation but not together. As a result, the next level of conditions can contain conditions that cannot be made true at the same time because they are made true by actions that cannot all be executed at the same time. Graphplan stores incompatibility of actions and conditions at each level, and uses them to determine the incompatibilities at the next level.\u000a \u000aThe graph produced by graphplan contains all conditions that can be made true and all actions that can be executed at some time point, but can also contain other conditions and actions. The actual search for a plan can be done by backward chaining (starting from the goal and recursively establishing which subgoals have to be reached to reach the goal). The graph is used in this phase to reduce the number of possibilities the algorithm has to consider.\u000a \u000a*A. Blum and M. Furts (1997). Fast planning through planning graph analysis. Artificial intelligence. 90:281-300.\u000a*Russell, Stuart, and Peter Norvig (2003). Artificial Intelligence: A Modern Approach, Second Edition. Upper Saddle River, New Jersey: Prentice Hall.\u000a*[http://www.cs.cmu.edu/~avrim/graphplan.html Avrim Blum's Graphplan home page]\u000a
p49
sg12
(lp50
(iversion
Paragraph
p51
(dp52
g10
VGraphplan is an algorithm for automated planning developed by Avrim Blum and Merrick Furst in 1995. Graphplan takes as input a planning problem expressed in STRIPS and produces, if any, a sequence of operations for reaching a goal state. The name graphplan is due its use of a graph as an intermediate structure to reduce the amount of search needed to find the solution.
p53
sg17
I00
sg18
Nsg19
Nsba(iversion
Paragraph
p54
(dp55
g10
V The graph used by graphplan is not the search space graph, a graph in which possible states are nodes and edges indicate reachability. The nodes of the graph are instead conditions and actions, arranged into alternate levels of conditions and actions.
p56
sg17
I00
sg18
Nsg19
Nsba(iversion
Paragraph
p57
(dp58
g10
VThe conditions of the first levels are those initially true. The third level contains all conditions that can actually be made true at the second time point by executing some actions, etc. The odd levels contain the actions that can be perfomed at each time step. By definition, each level (of actions or conditions) can be build from the previous one (of conditions or actions, respectively).
p59
sg17
I00
sg18
Nsg19
Nsba(iversion
Paragraph
p60
(dp61
g10
V A level of action can contain two actions that can be executed in isolation but not together. As a result, the next level of conditions can contain conditions that cannot be made true at the same time because they are made true by actions that cannot all be executed at the same time. Graphplan stores incompatibility of actions and conditions at each level, and uses them to determine the incompatibilities at the next level.
p62
sg17
I00
sg18
Nsg19
Nsba(iversion
Paragraph
p63
(dp64
g10
V The graph produced by graphplan contains all conditions that can be made true and all actions that can be executed at some time point, but can also contain other conditions and actions. The actual search for a plan can be done by backward chaining (starting from the goal and recursively establishing which subgoals have to be reached to reach the goal). The graph is used in this phase to reduce the number of possibilities the algorithm has to consider.
p65
sg17
I00
sg18
Nsg19
Nsba(iversion
Paragraph
p66
(dp67
g10
V *A. Blum and M. Furts (1997). Fast planning through planning graph analysis. Artificial intelligence. 90:281-300.*Russell, Stuart, and Peter Norvig (2003). Artificial Intelligence: A Modern Approach, Second Edition. Upper Saddle River, New Jersey: Prentice Hall.*[http://www.cs.cmu.edu/~avrim/graphplan.html Avrim Blum's Graphplan home page]
p68
sg17
I00
sg18
Nsg19
Nsbasg20
VTizio
p69
sba(iversion
Version
p70
(dp71
g7
g8
(S'\x07\xd6\x01\x0e\r;\x06\x00\x00\x00'
tRp72
sg10
VGraphplan is an algorithm for automated planning developed by Avrim Blum and Merrick Furst in 1995. Graphplan takes as input a planning problem expressed in STRIPS and produces, if any, a sequence of operations for reaching a goal state. The name graphplan is due its use of a graph as an intermediate structure to reduce the amount of search needed to find the solution.\u000a \u000aThe graph used by graphplan is not the search space graph, a graph in which possible states are nodes and edges indicate reachability. The nodes of the graph are instead conditions and actions, arranged into alternate levels of conditions and actions.\u000aThe conditions of the first levels are those initially true. The third level contains all conditions that can actually be made true at the second time point by executing some actions, etc. The odd levels contain the actions that can be perfomed at each time step. By definition, each level (of actions or conditions) can be built from the previous one (of conditions or actions, respectively).\u000a \u000aA level of action can contain two actions that can be executed in isolation but not together. As a result, the next level of conditions can contain conditions that cannot be made true at the same time because they are made true by actions that cannot all be executed at the same time. Graphplan stores incompatibility of actions and conditions at each level, and uses them to determine the incompatibilities at the next level.\u000a \u000aThe graph produced by graphplan contains all conditions that can be made true and all actions that can be executed at some time point, but can also contain other conditions and actions. The actual search for a plan can be done by backward chaining (starting from the goal and recursively establishing which subgoals have to be reached to reach the goal). The graph is used in this phase to reduce the number of possibilities the algorithm has to consider.\u000a \u000a*A. Blum and M. Furst (1997). Fast planning through planning graph analysis. Artificial intelligence. 90:281-300.\u000a*S. Russell and P. Norvig (2003). Artificial Intelligence: A Modern Approach, Second Edition. Upper Saddle River, New Jersey: Prentice Hall.\u000a*[http://www.cs.cmu.edu/~avrim/graphplan.html Avrim Blum's Graphplan home page]\u000a
p73
sg12
(lp74
(iversion
Paragraph
p75
(dp76
g10
VGraphplan is an algorithm for automated planning developed by Avrim Blum and Merrick Furst in 1995. Graphplan takes as input a planning problem expressed in STRIPS and produces, if any, a sequence of operations for reaching a goal state. The name graphplan is due its use of a graph as an intermediate structure to reduce the amount of search needed to find the solution.
p77
sg17
I00
sg18
Nsg19
Nsba(iversion
Paragraph
p78
(dp79
g10
V The graph used by graphplan is not the search space graph, a graph in which possible states are nodes and edges indicate reachability. The nodes of the graph are instead conditions and actions, arranged into alternate levels of conditions and actions.
p80
sg17
I00
sg18
Nsg19
Nsba(iversion
Paragraph
p81
(dp82
g10
VThe conditions of the first levels are those initially true. The third level contains all conditions that can actually be made true at the second time point by executing some actions, etc. The odd levels contain the actions that can be perfomed at each time step. By definition, each level (of actions or conditions) can be built from the previous one (of conditions or actions, respectively).
p83
sg17
I00
sg18
Nsg19
Nsba(iversion
Paragraph
p84
(dp85
g10
V A level of action can contain two actions that can be executed in isolation but not together. As a result, the next level of conditions can contain conditions that cannot be made true at the same time because they are made true by actions that cannot all be executed at the same time. Graphplan stores incompatibility of actions and conditions at each level, and uses them to determine the incompatibilities at the next level.
p86
sg17
I00
sg18
Nsg19
Nsba(iversion
Paragraph
p87
(dp88
g10
V The graph produced by graphplan contains all conditions that can be made true and all actions that can be executed at some time point, but can also contain other conditions and actions. The actual search for a plan can be done by backward chaining (starting from the goal and recursively establishing which subgoals have to be reached to reach the goal). The graph is used in this phase to reduce the number of possibilities the algorithm has to consider.
p89
sg17
I00
sg18
Nsg19
Nsba(iversion
Paragraph
p90
(dp91
g10
V *A. Blum and M. Furst (1997). Fast planning through planning graph analysis. Artificial intelligence. 90:281-300.*S. Russell and P. Norvig (2003). Artificial Intelligence: A Modern Approach, Second Edition. Upper Saddle River, New Jersey: Prentice Hall.*[http://www.cs.cmu.edu/~avrim/graphplan.html Avrim Blum's Graphplan home page]
p92
sg17
I00
sg18
Nsg19
Nsbasg20
VBluebot
p93
sba(iversion
Version
p94
(dp95
g7
g8
(S'\x07\xd6\x02\x1c\x06\x18\r\x00\x00\x00'
tRp96
sg10
VGraphplan is an algorithm for automated planning developed by Avrim Blum and Merrick Furst in 1995. Graphplan takes as input a planning problem expressed in STRIPS and produces, if any, a sequence of operations for reaching a goal state. The name graphplan is due its use of a graph as an intermediate structure to reduce the amount of search needed to find the solution.\u000a \u000aThe graph used by graphplan is not the search space graph, a graph in which possible states are nodes and edges indicate reachability. The nodes of the graph are instead conditions and actions, arranged into alternate levels of conditions and actions.\u000aThe conditions of the first levels are those initially true. The third level contains all conditions that can actually be made true at the second time point by executing some actions, etc. The odd levels contain the actions that can be perfomed at each time step. By definition, each level (of actions or conditions) can be built from the previous one (of conditions or actions, respectively).\u000a \u000aA level of action can contain two actions that can be executed in isolation but not together. As a result, the next level of conditions can contain conditions that cannot be made true at the same time because they are made true by actions that cannot all be executed at the same time. Graphplan stores incompatibility of actions and conditions at each level, and uses them to determine the incompatibilities at the next level.\u000a \u000aThe graph produced by graphplan contains all conditions that can be made true and all actions that can be executed at some time point, but can also contain other conditions and actions. The actual search for a plan can be done by backward chaining (starting from the goal and recursively establishing which subgoals have to be reached to reach the goal). The graph is used in this phase to reduce the number of possibilities the algorithm has to consider.\u000a \u000a*A. Blum and M. Furst (1997). Fast planning through planning graph analysis. Artificial intelligence. 90:281-300.\u000a*S. Russell and P. Norvig (2003). Artificial Intelligence: A Modern Approach, Second Edition. Upper Saddle River, New Jersey: Prentice Hall.\u000a*[http://www.cs.cmu.edu/~avrim/graphplan.html Avrim Blum's Graphplan home page]\u000a*[http://www.dmi.usherb.ca/~fournier/plplan.html PLPLAN : An open-source Java GraphPlan Implementation]\u000a
p97
sg12
(lp98
(iversion
Paragraph
p99
(dp100
g10
VGraphplan is an algorithm for automated planning developed by Avrim Blum and Merrick Furst in 1995. Graphplan takes as input a planning problem expressed in STRIPS and produces, if any, a sequence of operations for reaching a goal state. The name graphplan is due its use of a graph as an intermediate structure to reduce the amount of search needed to find the solution.
p101
sg17
I00
sg18
Nsg19
Nsba(iversion
Paragraph
p102
(dp103
g10
V The graph used by graphplan is not the search space graph, a graph in which possible states are nodes and edges indicate reachability. The nodes of the graph are instead conditions and actions, arranged into alternate levels of conditions and actions.
p104
sg17
I00
sg18
Nsg19
Nsba(iversion
Paragraph
p105
(dp106
g10
VThe conditions of the first levels are those initially true. The third level contains all conditions that can actually be made true at the second time point by executing some actions, etc. The odd levels contain the actions that can be perfomed at each time step. By definition, each level (of actions or conditions) can be built from the previous one (of conditions or actions, respectively).
p107
sg17
I00
sg18
Nsg19
Nsba(iversion
Paragraph
p108
(dp109
g10
V A level of action can contain two actions that can be executed in isolation but not together. As a result, the next level of conditions can contain conditions that cannot be made true at the same time because they are made true by actions that cannot all be executed at the same time. Graphplan stores incompatibility of actions and conditions at each level, and uses them to determine the incompatibilities at the next level.
p110
sg17
I00
sg18
Nsg19
Nsba(iversion
Paragraph
p111
(dp112
g10
V The graph produced by graphplan contains all conditions that can be made true and all actions that can be executed at some time point, but can also contain other conditions and actions. The actual search for a plan can be done by backward chaining (starting from the goal and recursively establishing which subgoals have to be reached to reach the goal). The graph is used in this phase to reduce the number of possibilities the algorithm has to consider.
p113
sg17
I00
sg18
Nsg19
Nsba(iversion
Paragraph
p114
(dp115
g10
V *A. Blum and M. Furst (1997). Fast planning through planning graph analysis. Artificial intelligence. 90:281-300.*S. Russell and P. Norvig (2003). Artificial Intelligence: A Modern Approach, Second Edition. Upper Saddle River, New Jersey: Prentice Hall.*[http://www.cs.cmu.edu/~avrim/graphplan.html Avrim Blum's Graphplan home page]*[http://www.dmi.usherb.ca/~fournier/plplan.html PLPLAN : An open-source Java GraphPlan Implementation]
p116
sg17
I00
sg18
Nsg19
Nsbasg20
S''
sba(iversion
Version
p117
(dp118
g7
g8
(S'\x07\xd6\x03\x1c\x152)\x00\x00\x00'
tRp119
sg10
VGraphplan is an algorithm for automated planning developed by Your Mom's ex-boyfriends roommate in 1995. Graphplan takes as input a planning problem expressed in STRIPS and produces, if any, a sequence of operations for reaching a goal state. The name graphplan is due its use of a graph as an intermediate structure to reduce the amount of search needed to find the solution.\u000a \u000aThe graph used by graphplan is not the search space graph, a graph in which possible states are nodes and edges indicate reachability. The nodes of the graph are instead conditions and actions, arranged into alternate levels of conditions and actions.\u000aThe conditions of the first levels are those initially true. The third level contains all conditions that can actually be made true at the second time point by executing some actions, etc. The odd levels contain the actions that can be perfomed at each time step. By definition, each level (of actions or conditions) can be built from the previous one (of conditions or actions, respectively).\u000a \u000aA level of action can contain two actions that can be executed in isolation but not together. As a result, the next level of conditions can contain conditions that cannot be made true at the same time because they are made true by actions that cannot all be executed at the same time. Graphplan stores incompatibility of actions and conditions at each level, and uses them to determine the incompatibilities at the next level.\u000a \u000aThe graph produced by graphplan contains all conditions that can be made true and all actions that can be executed at some time point, but can also contain other conditions and actions. The actual search for a plan can be done by backward chaining (starting from the goal and recursively establishing which subgoals have to be reached to reach the goal). The graph is used in this phase to reduce the number of possibilities the algorithm has to consider.\u000a \u000a*A. Blum and M. Furst (1997). Fast planning through planning graph analysis. Artificial intelligence. 90:281-300.\u000a*S. Russell and P. Norvig (2003). Artificial Intelligence: A Modern Approach, Second Edition. Upper Saddle River, New Jersey: Prentice Hall.\u000a*[http://www.cs.cmu.edu/~avrim/graphplan.html Avrim Blum's Graphplan home page]\u000a*[http://www.dmi.usherb.ca/~fournier/plplan.html PLPLAN : An open-source Java GraphPlan Implementation]\u000a
p120
sg12
(lp121
(iversion
Paragraph
p122
(dp123
g10
VGraphplan is an algorithm for automated planning developed by Your Mom's ex-boyfriends roommate in 1995. Graphplan takes as input a planning problem expressed in STRIPS and produces, if any, a sequence of operations for reaching a goal state. The name graphplan is due its use of a graph as an intermediate structure to reduce the amount of search needed to find the solution.
p124
sg17
I00
sg18
Nsg19
Nsba(iversion
Paragraph
p125
(dp126
g10
V The graph used by graphplan is not the search space graph, a graph in which possible states are nodes and edges indicate reachability. The nodes of the graph are instead conditions and actions, arranged into alternate levels of conditions and actions.
p127
sg17
I00
sg18
Nsg19
Nsba(iversion
Paragraph
p128
(dp129
g10
VThe conditions of the first levels are those initially true. The third level contains all conditions that can actually be made true at the second time point by executing some actions, etc. The odd levels contain the actions that can be perfomed at each time step. By definition, each level (of actions or conditions) can be built from the previous one (of conditions or actions, respectively).
p130
sg17
I00
sg18
Nsg19
Nsba(iversion
Paragraph
p131
(dp132
g10
V A level of action can contain two actions that can be executed in isolation but not together. As a result, the next level of conditions can contain conditions that cannot be made true at the same time because they are made true by actions that cannot all be executed at the same time. Graphplan stores incompatibility of actions and conditions at each level, and uses them to determine the incompatibilities at the next level.
p133
sg17
I00
sg18
Nsg19
Nsba(iversion
Paragraph
p134
(dp135
g10
V The graph produced by graphplan contains all conditions that can be made true and all actions that can be executed at some time point, but can also contain other conditions and actions. The actual search for a plan can be done by backward chaining (starting from the goal and recursively establishing which subgoals have to be reached to reach the goal). The graph is used in this phase to reduce the number of possibilities the algorithm has to consider.
p136
sg17
I00
sg18
Nsg19
Nsba(iversion
Paragraph
p137
(dp138
g10
V *A. Blum and M. Furst (1997). Fast planning through planning graph analysis. Artificial intelligence. 90:281-300.*S. Russell and P. Norvig (2003). Artificial Intelligence: A Modern Approach, Second Edition. Upper Saddle River, New Jersey: Prentice Hall.*[http://www.cs.cmu.edu/~avrim/graphplan.html Avrim Blum's Graphplan home page]*[http://www.dmi.usherb.ca/~fournier/plplan.html PLPLAN : An open-source Java GraphPlan Implementation]
p139
sg17
I00
sg18
Nsg19
Nsbasg20
S''
sba(iversion
Version
p140
(dp141
g7
g8
(S'\x07\xd6\x04\x0e\x0b1)\x00\x00\x00'
tRp142
sg10
VGraphplan is an algorithm for automated planning developed by Avrim Blum and Merrick Furst in 1995. Graphplan takes as input a planning problem expressed in STRIPS and produces, if any, a sequence of operations for reaching a goal state. The name graphplan is due its use of a graph as an intermediate structure to reduce the amount of search needed to find the solution.\u000aThe graph used by graphplan is not the search space graph, a graph in which possible states are nodes and edges indicate reachability. The nodes of the graph are instead conditions and actions, arranged into alternate levels of conditions and actions.\u000aThe conditions of the first levels are those initially true. The third level contains all conditions that can actually be made true at the second time point by executing some actions, etc. The odd levels contain the actions that can be perfomed at each time step. By definition, each level (of actions or conditions) can be built from the previous one (of conditions or actions, respectively).\u000aA level of action can contain two actions that can be executed in isolation but not together. As a result, the next level of conditions can contain conditions that cannot be made true at the same time because they are made true by actions that cannot all be executed at the same time. Graphplan stores incompatibility of actions and conditions at each level, and uses them to determine the incompatibilities at the next level.\u000aThe graph produced by graphplan contains all conditions that can be made true and all actions that can be executed at some time point, but can also contain other conditions and actions. The actual search for a plan can be done by backward chaining (starting from the goal and recursively establishing which subgoals have to be reached to reach the goal). The graph is used in this phase to reduce the number of possibilities the algorithm has to consider.\u000a*A. Blum and M. Furst (1997). Fast planning through planning graph analysis. Artificial intelligence. 90:281-300.\u000a*S. Russell and P. Norvig (2003). Artificial Intelligence: A Modern Approach, Second Edition. Upper Saddle River, New Jersey: Prentice Hall.\u000a*[http://www.cs.cmu.edu/~avrim/graphplan.html Avrim Blum's Graphplan home page]\u000a*[http://www.dmi.usherb.ca/~fournier/plplan.html PLPLAN : An open-source Java GraphPlan Implementation]\u000a
p143
sg12
(lp144
(iversion
Paragraph
p145
(dp146
g10
VGraphplan is an algorithm for automated planning developed by Avrim Blum and Merrick Furst in 1995. Graphplan takes as input a planning problem expressed in STRIPS and produces, if any, a sequence of operations for reaching a goal state. The name graphplan is due its use of a graph as an intermediate structure to reduce the amount of search needed to find the solution.
p147
sg17
I00
sg18
Nsg19
Nsba(iversion
Paragraph
p148
(dp149
g10
VThe graph used by graphplan is not the search space graph, a graph in which possible states are nodes and edges indicate reachability. The nodes of the graph are instead conditions and actions, arranged into alternate levels of conditions and actions.
p150
sg17
I00
sg18
Nsg19
Nsba(iversion
Paragraph
p151
(dp152
g10
VThe conditions of the first levels are those initially true. The third level contains all conditions that can actually be made true at the second time point by executing some actions, etc. The odd levels contain the actions that can be perfomed at each time step. By definition, each level (of actions or conditions) can be built from the previous one (of conditions or actions, respectively).
p153
sg17
I00
sg18
Nsg19
Nsba(iversion
Paragraph
p154
(dp155
g10
VA level of action can contain two actions that can be executed in isolation but not together. As a result, the next level of conditions can contain conditions that cannot be made true at the same time because they are made true by actions that cannot all be executed at the same time. Graphplan stores incompatibility of actions and conditions at each level, and uses them to determine the incompatibilities at the next level.
p156
sg17
I00
sg18
Nsg19
Nsba(iversion
Paragraph
p157
(dp158
g10
VThe graph produced by graphplan contains all conditions that can be made true and all actions that can be executed at some time point, but can also contain other conditions and actions. The actual search for a plan can be done by backward chaining (starting from the goal and recursively establishing which subgoals have to be reached to reach the goal). The graph is used in this phase to reduce the number of possibilities the algorithm has to consider.*A. Blum and M. Furst (1997). Fast planning through planning graph analysis. Artificial intelligence. 90:281-300.*S. Russell and P. Norvig (2003). Artificial Intelligence: A Modern Approach, Second Edition. Upper Saddle River, New Jersey: Prentice Hall.*[http://www.cs.cmu.edu/~avrim/graphplan.html Avrim Blum's Graphplan home page]*[http://www.dmi.usherb.ca/~fournier/plplan.html PLPLAN : An open-source Java GraphPlan Implementation]
p159
sg17
I00
sg18
Nsg19
Nsbasg20
VSmackBot
p160
sba(iversion
Version
p161
(dp162
g7
g8
(S'\x07\xd6\x07\x1c\x15&\x0e\x00\x00\x00'
tRp163
sg10
VGraphplan is an algorithm for automated planning developed by Avrim Blum and Merrick Furst in 1995. Graphplan takes as input a planning problem expressed in STRIPS and produces, if any, a sequence of operations for reaching a goal state. The name graphplan is due its use of a planning graph as an intermediate structure to reduce the amount of search needed to find the solution.\u000aThe graph used by graphplan is not the search space graph, a graph in which possible states are nodes and edges indicate reachability. The nodes of the graph are instead conditions and actions, arranged into alternate levels of conditions and actions.\u000aThe conditions of the first levels are those initially true. The third level contains all conditions that can actually be made true at the second time point by executing some actions, etc. The odd levels contain the actions that can be perfomed at each time step. By definition, each level (of actions or conditions) can be built from the previous one (of conditions or actions, respectively).\u000aA level of action can contain one or more actions that can be executed in isolation but not together. As a result, the next level of conditions can contain conditions that cannot be made true at the same time because they are made true by actions that cannot all be executed at the same time. Graphplan stores incompatibility of actions and conditions at each level, and uses them to determine the incompatibilities at the next level.\u000aThe graph produced by graphplan contains all conditions that can be made true and all actions that can be executed at some time point, but can also contain other conditions and actions. The actual search for a plan can be done by backward chaining (starting from the goal and recursively establishing which subgoals have to be reached to reach the goal) or by using an encoding of the problem in a propositional satisfiability or constraint satisfaction problem. The graph is used in this phase to reduce the number of possibilities the algorithm has to consider.\u000a*A. Blum and M. Furst (1997). Fast planning through planning graph analysis. Artificial intelligence. 90:281-300.\u000a*S. Russell and P. Norvig (2003). Artificial Intelligence: A Modern Approach, Second Edition. Upper Saddle River, New Jersey: Prentice Hall.\u000a*[http://www.cs.cmu.edu/~avrim/graphplan.html Avrim Blum's Graphplan home page]\u000a*[http://www.dmi.usherb.ca/~fournier/plplan.html PLPLAN : An open-source Java GraphPlan Implementation]\u000a
p164
sg12
(lp165
(iversion
Paragraph
p166
(dp167
g10
VGraphplan is an algorithm for automated planning developed by Avrim Blum and Merrick Furst in 1995. Graphplan takes as input a planning problem expressed in STRIPS and produces, if any, a sequence of operations for reaching a goal state. The name graphplan is due its use of a planning graph as an intermediate structure to reduce the amount of search needed to find the solution.
p168
sg17
I00
sg18
Nsg19
Nsba(iversion
Paragraph
p169
(dp170
g10
VThe graph used by graphplan is not the search space graph, a graph in which possible states are nodes and edges indicate reachability. The nodes of the graph are instead conditions and actions, arranged into alternate levels of conditions and actions.
p171
sg17
I00
sg18
Nsg19
Nsba(iversion
Paragraph
p172
(dp173
g10
VThe conditions of the first levels are those initially true. The third level contains all conditions that can actually be made true at the second time point by executing some actions, etc. The odd levels contain the actions that can be perfomed at each time step. By definition, each level (of actions or conditions) can be built from the previous one (of conditions or actions, respectively).
p174
sg17
I00
sg18
Nsg19
Nsba(iversion
Paragraph
p175
(dp176
g10
VA level of action can contain one or more actions that can be executed in isolation but not together. As a result, the next level of conditions can contain conditions that cannot be made true at the same time because they are made true by actions that cannot all be executed at the same time. Graphplan stores incompatibility of actions and conditions at each level, and uses them to determine the incompatibilities at the next level.
p177
sg17
I00
sg18
Nsg19
Nsba(iversion
Paragraph
p178
(dp179
g10
VThe graph produced by graphplan contains all conditions that can be made true and all actions that can be executed at some time point, but can also contain other conditions and actions. The actual search for a plan can be done by backward chaining (starting from the goal and recursively establishing which subgoals have to be reached to reach the goal) or by using an encoding of the problem in a propositional satisfiability or constraint satisfaction problem. The graph is used in this phase to reduce the number of possibilities the algorithm has to consider.*A. Blum and M. Furst (1997). Fast planning through planning graph analysis. Artificial intelligence. 90:281-300.*S. Russell and P. Norvig (2003). Artificial Intelligence: A Modern Approach, Second Edition. Upper Saddle River, New Jersey: Prentice Hall.*[http://www.cs.cmu.edu/~avrim/graphplan.html Avrim Blum's Graphplan home page]*[http://www.dmi.usherb.ca/~fournier/plplan.html PLPLAN : An open-source Java GraphPlan Implementation]
p180
sg17
I00
sg18
Nsg19
Nsbasg20
VJaibe
p181
sba(iversion
Version
p182
(dp183
g7
g8
(S'\x07\xd7\n\x01\x07\t(\x00\x00\x00'
tRp184
sg10
VGraphplan is an algorithm for automated planning developed by Avrim Blum and Merrick Furst in 1995. Graphplan takes as input a planning problem expressed in STRIPS and produces, if one is possible, a sequence of operations for reaching a goal state. The name graphplan is due its use of a planning graph as an intermediate structure to reduce the amount of search needed to find the solution.\u000aThe graph used by graphplan is not the search space graph, a graph in which possible states are nodes and edges indicate reachability. The nodes of the graph are instead conditions and actions, arranged into alternate levels of conditions and actions.\u000aThe conditions of the first levels are those initially true. The third level contains all conditions that can actually be made true at the second time point by executing some actions, etc. The odd levels contain the actions that can be performed at each time step. By definition, each level (of actions or conditions) can be built from the previous one (of conditions or actions, respectively).\u000aA level of action can contain one or more actions that can be executed in isolation but not together. As a result, the next level of conditions can contain conditions that cannot be made true at the same time because they are made true by actions that cannot all be executed at the same time. Graphplan stores incompatibility of actions and conditions at each level, and uses them to determine the incompatibilities at the next level.\u000aThe graph produced by graphplan contains all conditions that can be made true and all actions that can be executed at some time point, but can also contain other conditions and actions. The actual search for a plan can be done by backward chaining (starting from the goal and recursively establishing which subgoals have to be reached to reach the goal) or by using an encoding of the problem in a propositional satisfiability or constraint satisfaction problem. The graph is used in this phase to reduce the number of possibilities the algorithm has to consider.\u000a*A. Blum and M. Furst (1997). Fast planning through planning graph analysis. Artificial intelligence. 90:281-300.\u000a*S. Russell and P. Norvig (2003). Artificial Intelligence: A Modern Approach, Second Edition. Upper Saddle River, New Jersey: Prentice Hall.\u000a*[http://www.cs.cmu.edu/~avrim/graphplan.html Avrim Blum's Graphplan home page]\u000a*[http://www.philippe-fournier-viger.com/plplan.html PLPLAN: A Java GraphPlan Implementation]\u000a
p185
sg12
(lp186
(iversion
Paragraph
p187
(dp188
g10
VGraphplan is an algorithm for automated planning developed by Avrim Blum and Merrick Furst in 1995. Graphplan takes as input a planning problem expressed in STRIPS and produces, if one is possible, a sequence of operations for reaching a goal state. The name graphplan is due its use of a planning graph as an intermediate structure to reduce the amount of search needed to find the solution.
p189
sg17
I00
sg18
Nsg19
Nsba(iversion
Paragraph
p190
(dp191
g10
VThe graph used by graphplan is not the search space graph, a graph in which possible states are nodes and edges indicate reachability. The nodes of the graph are instead conditions and actions, arranged into alternate levels of conditions and actions.
p192
sg17
I00
sg18
Nsg19
Nsba(iversion
Paragraph
p193
(dp194
g10
VThe conditions of the first levels are those initially true. The third level contains all conditions that can actually be made true at the second time point by executing some actions, etc. The odd levels contain the actions that can be performed at each time step. By definition, each level (of actions or conditions) can be built from the previous one (of conditions or actions, respectively).
p195
sg17
I00
sg18
Nsg19
Nsba(iversion
Paragraph
p196
(dp197
g10
VA level of action can contain one or more actions that can be executed in isolation but not together. As a result, the next level of conditions can contain conditions that cannot be made true at the same time because they are made true by actions that cannot all be executed at the same time. Graphplan stores incompatibility of actions and conditions at each level, and uses them to determine the incompatibilities at the next level.
p198
sg17
I00
sg18
Nsg19
Nsba(iversion
Paragraph
p199
(dp200
g10
VThe graph produced by graphplan contains all conditions that can be made true and all actions that can be executed at some time point, but can also contain other conditions and actions. The actual search for a plan can be done by backward chaining (starting from the goal and recursively establishing which subgoals have to be reached to reach the goal) or by using an encoding of the problem in a propositional satisfiability or constraint satisfaction problem. The graph is used in this phase to reduce the number of possibilities the algorithm has to consider.*A. Blum and M. Furst (1997). Fast planning through planning graph analysis. Artificial intelligence. 90:281-300.*S. Russell and P. Norvig (2003). Artificial Intelligence: A Modern Approach, Second Edition. Upper Saddle River, New Jersey: Prentice Hall.*[http://www.cs.cmu.edu/~avrim/graphplan.html Avrim Blum's Graphplan home page]*[http://www.philippe-fournier-viger.com/plplan.html PLPLAN: A Java GraphPlan Implementation]
p201
sg17
I00
sg18
Nsg19
Nsbasg20
VZeno Gantner
p202
sba(iversion
Version
p203
(dp204
g7
g8
(S'\x07\xd7\x0c\t\x0b\x00\x14\x00\x00\x00'
tRp205
sg10
VGraphplan is an algorithm for automated planning developed by Avrim Blum and Merrick Furst in 1995. Graphplan takes as input a planning problem expressed in STRIPS and produces, if one is possible, a sequence of operations for reaching a goal state. The name graphplan is due its use of a planning graph as an intermediate structure to reduce the amount of search needed to find the solution.\u000aThe graph used by graphplan is not the search space graph, a graph in which possible states are nodes and edges indicate reachability. The nodes of the graph are instead conditions and actions, arranged into alternate levels of conditions and actions.\u000aThe conditions of the first levels are those initially true. The third level contains all conditions that can actually be made true at the second time point by executing some actions, etc. The odd levels contain the actions that can be performed at each time step. By definition, each level (of actions or conditions) can be built from the previous one (of conditions or actions, respectively).\u000aA level of action can contain one or more actions that can be executed in isolation but not together. As a result, the next level of conditions can contain conditions that cannot be made true at the same time because they are made true by actions that cannot all be executed at the same time. Graphplan stores incompatibility of actions and conditions at each level, and uses them to determine the incompatibilities at the next level.\u000aThe graph produced by graphplan contains all conditions that can be made true and all actions that can be executed at some time point, but can also contain other conditions and actions. The actual search for a plan can be done by backward chaining (starting from the goal and recursively establishing which subgoals have to be reached to reach the goal) or by using an encoding of the problem in a propositional satisfiability or constraint satisfaction problem. The graph is used in this phase to reduce the number of possibilities the algorithm has to consider.\u000a*A. Blum and M. Furst (1997). Fast planning through planning graph analysis. Artificial intelligence. 90:281-300.\u000a*\u000a*[http://www.cs.cmu.edu/~avrim/graphplan.html Avrim Blum's Graphplan home page]\u000a*[http://www.philippe-fournier-viger.com/plplan.html PLPLAN: A Java GraphPlan Implementation]\u000a
p206
sg12
(lp207
(iversion
Paragraph
p208
(dp209
g10
VGraphplan is an algorithm for automated planning developed by Avrim Blum and Merrick Furst in 1995. Graphplan takes as input a planning problem expressed in STRIPS and produces, if one is possible, a sequence of operations for reaching a goal state. The name graphplan is due its use of a planning graph as an intermediate structure to reduce the amount of search needed to find the solution.
p210
sg17
I00
sg18
Nsg19
Nsba(iversion
Paragraph
p211
(dp212
g10
VThe graph used by graphplan is not the search space graph, a graph in which possible states are nodes and edges indicate reachability. The nodes of the graph are instead conditions and actions, arranged into alternate levels of conditions and actions.
p213
sg17
I00
sg18
Nsg19
Nsba(iversion
Paragraph
p214
(dp215
g10
VThe conditions of the first levels are those initially true. The third level contains all conditions that can actually be made true at the second time point by executing some actions, etc. The odd levels contain the actions that can be performed at each time step. By definition, each level (of actions or conditions) can be built from the previous one (of conditions or actions, respectively).
p216
sg17
I00
sg18
Nsg19
Nsba(iversion
Paragraph
p217
(dp218
g10
VA level of action can contain one or more actions that can be executed in isolation but not together. As a result, the next level of conditions can contain conditions that cannot be made true at the same time because they are made true by actions that cannot all be executed at the same time. Graphplan stores incompatibility of actions and conditions at each level, and uses them to determine the incompatibilities at the next level.
p219
sg17
I00
sg18
Nsg19
Nsba(iversion
Paragraph
p220
(dp221
g10
VThe graph produced by graphplan contains all conditions that can be made true and all actions that can be executed at some time point, but can also contain other conditions and actions. The actual search for a plan can be done by backward chaining (starting from the goal and recursively establishing which subgoals have to be reached to reach the goal) or by using an encoding of the problem in a propositional satisfiability or constraint satisfaction problem. The graph is used in this phase to reduce the number of possibilities the algorithm has to consider.*A. Blum and M. Furst (1997). Fast planning through planning graph analysis. Artificial intelligence. 90:281-300.**[http://www.cs.cmu.edu/~avrim/graphplan.html Avrim Blum's Graphplan home page]*[http://www.philippe-fournier-viger.com/plplan.html PLPLAN: A Java GraphPlan Implementation]
p222
sg17
I00
sg18
Nsg19
Nsbasg20
VCharlesGillingham
p223
sba(iversion
Version
p224
(dp225
g7
g8
(S'\x07\xd8\x0b\n\x02\t\x0e\x00\x00\x00'
tRp226
sg10
VGraphplan is an algorithm for automated planning developed by Avrim Blum and Merrick Furst in 1995. Graphplan takes as input a planning problem expressed in STRIPS and produces, if one is possible, a sequence of operations for reaching a goal state. The name graphplan is due to the use of a novel planning graph to reduce the amount of search needed to find the solution from straightforward exploration of the state space graph, in which the nodes are possible states and edges indicate reachability through a certain action.\u000aIn Graphplan's planning graph nodes are actions and propositions, arranged into alternate levels, and edges are of three kinds: from a proposition to the actions for which it is a condition, and from an action to the propositions it makes true or false; the first level contains true propositions representing the initial state. Lists of incompatible propositions that cannot be true at the same time and incompatible actions that cannot be executed together are also maintained.\u000aThe algorithm then iteratively extends the planning graph, proving that there are no solutions of length l-1 before looking for plans of length l by backward chaining: supposing the goals are true, Graphplan looks for the actions and previous states from which the goals can be reached, pruning as many of them as possible thanks to incompatibility information.     \u000a*A. Blum and M. Furst (1997). Fast planning through planning graph analysis. Artificial intelligence. 90:281-300.\u000a*\u000a*[http://www.cs.cmu.edu/~avrim/graphplan.html Avrim Blum's Graphplan home page]\u000a*[http://www.philippe-fournier-viger.com/plplan.html PLPLAN: A Java GraphPlan Implementation]\u000a
p227
sg12
(lp228
(iversion
Paragraph
p229
(dp230
g10
VGraphplan is an algorithm for automated planning developed by Avrim Blum and Merrick Furst in 1995. Graphplan takes as input a planning problem expressed in STRIPS and produces, if one is possible, a sequence of operations for reaching a goal state. The name graphplan is due to the use of a novel planning graph to reduce the amount of search needed to find the solution from straightforward exploration of the state space graph, in which the nodes are possible states and edges indicate reachability through a certain action.
p231
sg17
I00
sg18
Nsg19
Nsba(iversion
Paragraph
p232
(dp233
g10
VIn Graphplan's planning graph nodes are actions and propositions, arranged into alternate levels, and edges are of three kinds: from a proposition to the actions for which it is a condition, and from an action to the propositions it makes true or false; the first level contains true propositions representing the initial state. Lists of incompatible propositions that cannot be true at the same time and incompatible actions that cannot be executed together are also maintained.
p234
sg17
I00
sg18
Nsg19
Nsba(iversion
Paragraph
p235
(dp236
g10
VThe algorithm then iteratively extends the planning graph, proving that there are no solutions of length l-1 before looking for plans of length l by backward chaining: supposing the goals are true, Graphplan looks for the actions and previous states from which the goals can be reached, pruning as many of them as possible thanks to incompatibility information.     *A. Blum and M. Furst (1997). Fast planning through planning graph analysis. Artificial intelligence. 90:281-300.**[http://www.cs.cmu.edu/~avrim/graphplan.html Avrim Blum's Graphplan home page]*[http://www.philippe-fournier-viger.com/plplan.html PLPLAN: A Java GraphPlan Implementation]
p237
sg17
I00
sg18
Nsg19
Nsbasg20
VLightbot
p238
sba(iversion
Version
p239
(dp240
g7
g8
(S'\x07\xd9\x0c\x16\r\x17\x11\x00\x00\x00'
tRp241
sg10
VGraphplan is an algorithm for automated planning developed by Avrim Blum and Merrick Furst in 1995. Graphplan takes as input a planning problem expressed in STRIPS and produces, if one is possible, a sequence of operations for reaching a goal state. The name graphplan is due to the use of a novel planning graph to reduce the amount of search needed to find the solution from straightforward exploration of the state space graph, in which the nodes are possible states and edges indicate reachability through a certain action.\u000aIn Graphplan's planning graph nodes are actions and propositions, arranged into alternate levels, and edges are of three kinds: from a proposition to the actions for which it is a condition, and from an action to the propositions it makes true or false; the first level contains true propositions representing the initial state. Lists of incompatible propositions that cannot be true at the same time and incompatible actions that cannot be executed together are also maintained.\u000aThe algorithm then iteratively extends the planning graph, proving that there are no solutions of length l-1 before looking for plans of length l by backward chaining: supposing the goals are true, Graphplan looks for the actions and previous states from which the goals can be reached, pruning as many of them as possible thanks to incompatibility information.     \u000a*A. Blum and M. Furst (1997). Fast planning through planning graph analysis. Artificial intelligence. 90:281-300.\u000a*\u000a*[http://www.cs.cmu.edu/~avrim/graphplan.html Avrim Blum's Graphplan home page]\u000a*[http://www.philippe-fournier-viger.com/plplan.html PLPLAN: A Java GraphPlan Implementation]\u000a*[http://nplanner.codeplex.com NPlanner: A .NET GraphPlan Implementation]\u000a
p242
sg12
(lp243
(iversion
Paragraph
p244
(dp245
g10
VGraphplan is an algorithm for automated planning developed by Avrim Blum and Merrick Furst in 1995. Graphplan takes as input a planning problem expressed in STRIPS and produces, if one is possible, a sequence of operations for reaching a goal state. The name graphplan is due to the use of a novel planning graph to reduce the amount of search needed to find the solution from straightforward exploration of the state space graph, in which the nodes are possible states and edges indicate reachability through a certain action.
p246
sg17
I00
sg18
Nsg19
Nsba(iversion
Paragraph
p247
(dp248
g10
VIn Graphplan's planning graph nodes are actions and propositions, arranged into alternate levels, and edges are of three kinds: from a proposition to the actions for which it is a condition, and from an action to the propositions it makes true or false; the first level contains true propositions representing the initial state. Lists of incompatible propositions that cannot be true at the same time and incompatible actions that cannot be executed together are also maintained.
p249
sg17
I00
sg18
Nsg19
Nsba(iversion
Paragraph
p250
(dp251
g10
VThe algorithm then iteratively extends the planning graph, proving that there are no solutions of length l-1 before looking for plans of length l by backward chaining: supposing the goals are true, Graphplan looks for the actions and previous states from which the goals can be reached, pruning as many of them as possible thanks to incompatibility information.     *A. Blum and M. Furst (1997). Fast planning through planning graph analysis. Artificial intelligence. 90:281-300.**[http://www.cs.cmu.edu/~avrim/graphplan.html Avrim Blum's Graphplan home page]*[http://www.philippe-fournier-viger.com/plplan.html PLPLAN: A Java GraphPlan Implementation]*[http://nplanner.codeplex.com NPlanner: A .NET GraphPlan Implementation]
p252
sg17
I00
sg18
Nsg19
Nsbasg20
S''
sba(iversion
Version
p253
(dp254
g7
g8
(S'\x07\xda\x07\x1b\x054\x08\x00\x00\x00'
tRp255
sg10
VGraphplan is an algorithm for automated planning developed by Avrim Blum and Merrick Furst in 1995. Graphplan takes as input a planning problem expressed in STRIPS and produces, if one is possible, a sequence of operations for reaching a goal state. The name graphplan is due to the use of a novel planning graph to reduce the amount of search needed to find the solution from straightforward exploration of the state space graph, in which the nodes are possible states and edges indicate reachability through a certain action.\u000aIn Graphplan's planning graph nodes are actions and atomic facts, arranged into alternate levels, and edges are of three kinds: from an atomic fact to the actions for which it is a condition, and from an action to the atomic facts it makes true or false; the first level contains true true atomic facts identifying the initial state. Lists of incompatible facts that cannot be true at the same time and incompatible actions that cannot be executed together are also maintained.\u000aThe algorithm then iteratively extends the planning graph, proving that there are no solutions of length l-1 before looking for plans of length l by backward chaining: supposing the goals are true, Graphplan looks for the actions and previous states from which the goals can be reached, pruning as many of them as possible thanks to incompatibility information.     \u000a*A. Blum and M. Furst (1997). Fast planning through planning graph analysis. Artificial intelligence. 90:281-300.\u000a*\u000a*[http://www.cs.cmu.edu/~avrim/graphplan.html Avrim Blum's Graphplan home page]\u000a*[http://www.philippe-fournier-viger.com/plplan.html PLPLAN: A Java GraphPlan Implementation]\u000a*[http://nplanner.codeplex.com NPlanner: A .NET GraphPlan Implementation]\u000a
p256
sg12
(lp257
(iversion
Paragraph
p258
(dp259
g10
VGraphplan is an algorithm for automated planning developed by Avrim Blum and Merrick Furst in 1995. Graphplan takes as input a planning problem expressed in STRIPS and produces, if one is possible, a sequence of operations for reaching a goal state. The name graphplan is due to the use of a novel planning graph to reduce the amount of search needed to find the solution from straightforward exploration of the state space graph, in which the nodes are possible states and edges indicate reachability through a certain action.
p260
sg17
I00
sg18
Nsg19
Nsba(iversion
Paragraph
p261
(dp262
g10
VIn Graphplan's planning graph nodes are actions and atomic facts, arranged into alternate levels, and edges are of three kinds: from an atomic fact to the actions for which it is a condition, and from an action to the atomic facts it makes true or false; the first level contains true true atomic facts identifying the initial state. Lists of incompatible facts that cannot be true at the same time and incompatible actions that cannot be executed together are also maintained.
p263
sg17
I00
sg18
Nsg19
Nsba(iversion
Paragraph
p264
(dp265
g10
VThe algorithm then iteratively extends the planning graph, proving that there are no solutions of length l-1 before looking for plans of length l by backward chaining: supposing the goals are true, Graphplan looks for the actions and previous states from which the goals can be reached, pruning as many of them as possible thanks to incompatibility information.     *A. Blum and M. Furst (1997). Fast planning through planning graph analysis. Artificial intelligence. 90:281-300.**[http://www.cs.cmu.edu/~avrim/graphplan.html Avrim Blum's Graphplan home page]*[http://www.philippe-fournier-viger.com/plplan.html PLPLAN: A Java GraphPlan Implementation]*[http://nplanner.codeplex.com NPlanner: A .NET GraphPlan Implementation]
p266
sg17
I00
sg18
Nsg19
Nsbasg20
S''
sba(iversion
Version
p267
(dp268
g7
g8
(S'\x07\xda\x08\t\x07\r\x07\x00\x00\x00'
tRp269
sg10
VGraphplan is an algorithm for automated planning developed by Avrim Blum and Merrick Furst in 1995. Graphplan takes as input a planning problem expressed in STRIPS and produces, if one is possible, a sequence of operations for reaching a goal state. The name graphplan is due to the use of a novel planning graph to reduce the amount of search needed to find the solution from straightforward exploration of the state space graph, in which the nodes are possible states and edges indicate reachability through a certain action.\u000aIn Graphplan's planning graph nodes are actions and atomic facts, arranged into alternate levels, and edges are of three kinds: from an atomic fact to the actions for which it is a condition, and from an action to the atomic facts it makes true or false; the first level contains true true atomic facts identifying the initial state. Lists of incompatible facts that cannot be true at the same time and incompatible actions that cannot be executed together are also maintained.\u000aThe algorithm then iteratively extends the planning graph, proving that there are no solutions of length l-1 before looking for plans of length l by backward chaining: supposing the goals are true, Graphplan looks for the actions and previous states from which the goals can be reached, pruning as many of them as possible thanks to incompatibility information.\u000aA closely related approach to planning is the Planning as Satisfiability (Satplan). Both reduce the automated planning problem to search for plans of different fixed horizon lengths.\u000a*A. Blum and M. Furst (1997). Fast planning through planning graph analysis. Artificial intelligence. 90:281-300.\u000a*\u000a*[http://www.cs.cmu.edu/~avrim/graphplan.html Avrim Blum's Graphplan home page]\u000a*[http://www.philippe-fournier-viger.com/plplan.html PLPLAN: A Java GraphPlan Implementation]\u000a*[http://nplanner.codeplex.com NPlanner: A .NET GraphPlan Implementation]\u000a
p270
sg12
(lp271
(iversion
Paragraph
p272
(dp273
g10
VGraphplan is an algorithm for automated planning developed by Avrim Blum and Merrick Furst in 1995. Graphplan takes as input a planning problem expressed in STRIPS and produces, if one is possible, a sequence of operations for reaching a goal state. The name graphplan is due to the use of a novel planning graph to reduce the amount of search needed to find the solution from straightforward exploration of the state space graph, in which the nodes are possible states and edges indicate reachability through a certain action.
p274
sg17
I00
sg18
Nsg19
Nsba(iversion
Paragraph
p275
(dp276
g10
VIn Graphplan's planning graph nodes are actions and atomic facts, arranged into alternate levels, and edges are of three kinds: from an atomic fact to the actions for which it is a condition, and from an action to the atomic facts it makes true or false; the first level contains true true atomic facts identifying the initial state. Lists of incompatible facts that cannot be true at the same time and incompatible actions that cannot be executed together are also maintained.
p277
sg17
I00
sg18
Nsg19
Nsba(iversion
Paragraph
p278
(dp279
g10
VThe algorithm then iteratively extends the planning graph, proving that there are no solutions of length l-1 before looking for plans of length l by backward chaining: supposing the goals are true, Graphplan looks for the actions and previous states from which the goals can be reached, pruning as many of them as possible thanks to incompatibility information.
p280
sg17
I00
sg18
Nsg19
Nsba(iversion
Paragraph
p281
(dp282
g10
VA closely related approach to planning is the Planning as Satisfiability (Satplan). Both reduce the automated planning problem to search for plans of different fixed horizon lengths.*A. Blum and M. Furst (1997). Fast planning through planning graph analysis. Artificial intelligence. 90:281-300.**[http://www.cs.cmu.edu/~avrim/graphplan.html Avrim Blum's Graphplan home page]*[http://www.philippe-fournier-viger.com/plplan.html PLPLAN: A Java GraphPlan Implementation]*[http://nplanner.codeplex.com NPlanner: A .NET GraphPlan Implementation]
p283
sg17
I00
sg18
Nsg19
Nsbasg20
S''
sba(iversion
Version
p284
(dp285
g7
g8
(S'\x07\xda\x08\x10\x12\x1d\x18\x00\x00\x00'
tRp286
sg10
VGraphplan is an algorithm for automated planning developed by Avrim Blum and Merrick Furst in 1995. Graphplan takes as input a planning problem expressed in STRIPS and produces, if one is possible, a sequence of operations for reaching a goal state. The name graphplan is due to the use of a novel planning graph to reduce the amount of search needed to find the solution from straightforward exploration of the state space graph, in which the nodes are possible states and edges indicate reachability through a certain action.\u000aIn Graphplan's planning graph nodes are actions and atomic facts, arranged into alternate levels, and edges are of three kinds: from an atomic fact to the actions for which it is a condition, and from an action to the atomic facts it makes true or false; the first level contains true true atomic facts identifying the initial state. Lists of incompatible facts that cannot be true at the same time and incompatible actions that cannot be executed together are also maintained.\u000aThe algorithm then iteratively extends the planning graph, proving that there are no solutions of length l-1 before looking for plans of length l by backward chaining: supposing the goals are true, Graphplan looks for the actions and previous states from which the goals can be reached, pruning as many of them as possible thanks to incompatibility information.\u000aA closely related approach to planning is the Planning as Satisfiability (Satplan). Both reduce the automated planning problem to search for plans of different fixed horizon lengths.\u000a*A. Blum and M. Furst (1997). Fast planning through planning graph analysis. Artificial intelligence. 90:281-300.\u000a*\u000a*[http://www.cs.cmu.edu/~avrim/graphplan.html Avrim Blum's Graphplan home page]\u000a*[http://www.philippe-fournier-viger.com/plplan.html PLPLAN: A Java GraphPlan Implementation]\u000a*[http://nplanner.codeplex.com NPlanner: A .NET GraphPlan Implementation]\u000a*[http://emplan.sourceforge.net/ Implementations of Graphplan]\u000a
p287
sg12
(lp288
(iversion
Paragraph
p289
(dp290
g10
VGraphplan is an algorithm for automated planning developed by Avrim Blum and Merrick Furst in 1995. Graphplan takes as input a planning problem expressed in STRIPS and produces, if one is possible, a sequence of operations for reaching a goal state. The name graphplan is due to the use of a novel planning graph to reduce the amount of search needed to find the solution from straightforward exploration of the state space graph, in which the nodes are possible states and edges indicate reachability through a certain action.
p291
sg17
I00
sg18
Nsg19
Nsba(iversion
Paragraph
p292
(dp293
g10
VIn Graphplan's planning graph nodes are actions and atomic facts, arranged into alternate levels, and edges are of three kinds: from an atomic fact to the actions for which it is a condition, and from an action to the atomic facts it makes true or false; the first level contains true true atomic facts identifying the initial state. Lists of incompatible facts that cannot be true at the same time and incompatible actions that cannot be executed together are also maintained.
p294
sg17
I00
sg18
Nsg19
Nsba(iversion
Paragraph
p295
(dp296
g10
VThe algorithm then iteratively extends the planning graph, proving that there are no solutions of length l-1 before looking for plans of length l by backward chaining: supposing the goals are true, Graphplan looks for the actions and previous states from which the goals can be reached, pruning as many of them as possible thanks to incompatibility information.
p297
sg17
I00
sg18
Nsg19
Nsba(iversion
Paragraph
p298
(dp299
g10
VA closely related approach to planning is the Planning as Satisfiability (Satplan). Both reduce the automated planning problem to search for plans of different fixed horizon lengths.*A. Blum and M. Furst (1997). Fast planning through planning graph analysis. Artificial intelligence. 90:281-300.**[http://www.cs.cmu.edu/~avrim/graphplan.html Avrim Blum's Graphplan home page]*[http://www.philippe-fournier-viger.com/plplan.html PLPLAN: A Java GraphPlan Implementation]*[http://nplanner.codeplex.com NPlanner: A .NET GraphPlan Implementation]*[http://emplan.sourceforge.net/ Implementations of Graphplan]
p300
sg17
I00
sg18
Nsg19
Nsbasg20
S''
sba(iversion
Version
p301
(dp302
g7
g8
(S'\x07\xdc\x06\x19\x15#%\x00\x00\x00'
tRp303
sg10
VGraphplan is an algorithm for automated planning developed by Avrim Blum and Merrick Furst in 1995. Graphplan takes as input a planning problem expressed in STRIPS and produces, if one is possible, a sequence of operations for reaching a goal state. The name graphplan is due to the use of a novel planning graph to reduce the amount of search needed to find the solution from straightforward exploration of the state space graph, in which the nodes are possible states and edges indicate reachability through a certain action.\u000aIn Graphplan's planning graph nodes are actions and atomic facts, arranged into alternate levels, and edges are of three kinds: from an atomic fact to the actions for which it is a condition, and from an action to the atomic facts it makes true or false; the first level contains true atomic facts identifying the initial state. Lists of incompatible facts that cannot be true at the same time and incompatible actions that cannot be executed together are also maintained.\u000aThe algorithm then iteratively extends the planning graph, proving that there are no solutions of length l-1 before looking for plans of length l by backward chaining: supposing the goals are true, Graphplan looks for the actions and previous states from which the goals can be reached, pruning as many of them as possible thanks to incompatibility information.\u000aA closely related approach to planning is the Planning as Satisfiability (Satplan). Both reduce the automated planning problem to search for plans of different fixed horizon lengths.\u000a*A. Blum and M. Furst (1997). Fast planning through planning graph analysis. Artificial intelligence. 90:281-300.\u000a*\u000a*[http://www.cs.cmu.edu/~avrim/graphplan.html Avrim Blum's Graphplan home page]\u000a*[http://www.philippe-fournier-viger.com/plplan.html PLPLAN: A Java GraphPlan Implementation]\u000a*[http://nplanner.codeplex.com NPlanner: A .NET GraphPlan Implementation]\u000a*[http://emplan.sourceforge.net/ Emplan and JavaGP: C++ and Java implementations of Graphplan]\u000a
p304
sg12
(lp305
(iversion
Paragraph
p306
(dp307
g10
VGraphplan is an algorithm for automated planning developed by Avrim Blum and Merrick Furst in 1995. Graphplan takes as input a planning problem expressed in STRIPS and produces, if one is possible, a sequence of operations for reaching a goal state. The name graphplan is due to the use of a novel planning graph to reduce the amount of search needed to find the solution from straightforward exploration of the state space graph, in which the nodes are possible states and edges indicate reachability through a certain action.
p308
sg17
I00
sg18
Nsg19
Nsba(iversion
Paragraph
p309
(dp310
g10
VIn Graphplan's planning graph nodes are actions and atomic facts, arranged into alternate levels, and edges are of three kinds: from an atomic fact to the actions for which it is a condition, and from an action to the atomic facts it makes true or false; the first level contains true atomic facts identifying the initial state. Lists of incompatible facts that cannot be true at the same time and incompatible actions that cannot be executed together are also maintained.
p311
sg17
I00
sg18
Nsg19
Nsba(iversion
Paragraph
p312
(dp313
g10
VThe algorithm then iteratively extends the planning graph, proving that there are no solutions of length l-1 before looking for plans of length l by backward chaining: supposing the goals are true, Graphplan looks for the actions and previous states from which the goals can be reached, pruning as many of them as possible thanks to incompatibility information.
p314
sg17
I00
sg18
Nsg19
Nsba(iversion
Paragraph
p315
(dp316
g10
VA closely related approach to planning is the Planning as Satisfiability (Satplan). Both reduce the automated planning problem to search for plans of different fixed horizon lengths.*A. Blum and M. Furst (1997). Fast planning through planning graph analysis. Artificial intelligence. 90:281-300.**[http://www.cs.cmu.edu/~avrim/graphplan.html Avrim Blum's Graphplan home page]*[http://www.philippe-fournier-viger.com/plplan.html PLPLAN: A Java GraphPlan Implementation]*[http://nplanner.codeplex.com NPlanner: A .NET GraphPlan Implementation]*[http://emplan.sourceforge.net/ Emplan and JavaGP: C++ and Java implementations of Graphplan]
p317
sg17
I00
sg18
Nsg19
Nsbasg20
VSchreiberBike
p318
sba(iversion
Version
p319
(dp320
g7
g8
(S'\x07\xdd\x03\x0c\x115\x01\x00\x00\x00'
tRp321
sg10
VGraphplan is an algorithm for automated planning developed by Avrim Blum and Merrick Furst in 1995. Graphplan takes as input a planning problem expressed in STRIPS and produces, if one is possible, a sequence of operations for reaching a goal state. \u000aThe name graphplan is due to the use of a novel planning graph, to reduce the amount of search needed to find the solution from straightforward exploration of the state space graph.\u000aIn the state space graph:\u000a* the nodes are possible states,\u000a* and the edges indicate reachability through a certain action.\u000aOn the contrary, in Graphplan's planning graph:\u000a* the nodes are actions and atomic facts, arranged into alternate levels, \u000a* and the edges are of two kinds: \u000a*# from an atomic fact to the actions for which it is a condition, \u000a*# from an action to the atomic facts it makes true or false.\u000athe first level contains true atomic facts identifying the initial state. \u000aLists of incompatible facts that cannot be true at the same time and incompatible actions that cannot be executed together are also maintained.\u000aThe algorithm then iteratively extends the planning graph, proving that there are no solutions of length l-1 before looking for plans of length l by backward chaining: supposing the goals are true, Graphplan looks for the actions and previous states from which the goals can be reached, pruning as many of them as possible thanks to incompatibility information.\u000aA closely related approach to planning is the Planning as Satisfiability (Satplan). Both reduce the automated planning problem to search for plans of different fixed horizon lengths.\u000a*A. Blum and M. Furst (1997). Fast planning through planning graph analysis. Artificial intelligence. 90:281-300.\u000a*\u000a*[http://www.cs.cmu.edu/~avrim/graphplan.html Avrim Blum's Graphplan home page]\u000a*[http://www.philippe-fournier-viger.com/plplan.html PLPLAN: A Java GraphPlan Implementation]\u000a*[http://nplanner.codeplex.com NPlanner: A .NET GraphPlan Implementation]\u000a*[http://emplan.sourceforge.net/ Emplan and JavaGP: C++ and Java implementations of Graphplan]\u000a
p322
sg12
(lp323
(iversion
Paragraph
p324
(dp325
g10
VGraphplan is an algorithm for automated planning developed by Avrim Blum and Merrick Furst in 1995. Graphplan takes as input a planning problem expressed in STRIPS and produces, if one is possible, a sequence of operations for reaching a goal state. The name graphplan is due to the use of a novel planning graph, to reduce the amount of search needed to find the solution from straightforward exploration of the state space graph.
p326
sg17
I00
sg18
Nsg19
Nsba(iversion
Paragraph
p327
(dp328
g10
VIn the state space graph:* the nodes are possible states,* and the edges indicate reachability through a certain action.
p329
sg17
I00
sg18
Nsg19
Nsba(iversion
Paragraph
p330
(dp331
g10
VOn the contrary, in Graphplan's planning graph:* the nodes are actions and atomic facts, arranged into alternate levels, * and the edges are of two kinds: *# from an atomic fact to the actions for which it is a condition, *# from an action to the atomic facts it makes true or false.
p332
sg17
I00
sg18
Nsg19
Nsba(iversion
Paragraph
p333
(dp334
g10
Vthe first level contains true atomic facts identifying the initial state. Lists of incompatible facts that cannot be true at the same time and incompatible actions that cannot be executed together are also maintained.
p335
sg17
I00
sg18
Nsg19
Nsba(iversion
Paragraph
p336
(dp337
g10
VThe algorithm then iteratively extends the planning graph, proving that there are no solutions of length l-1 before looking for plans of length l by backward chaining: supposing the goals are true, Graphplan looks for the actions and previous states from which the goals can be reached, pruning as many of them as possible thanks to incompatibility information.
p338
sg17
I00
sg18
Nsg19
Nsba(iversion
Paragraph
p339
(dp340
g10
VA closely related approach to planning is the Planning as Satisfiability (Satplan). Both reduce the automated planning problem to search for plans of different fixed horizon lengths.*A. Blum and M. Furst (1997). Fast planning through planning graph analysis. Artificial intelligence. 90:281-300.**[http://www.cs.cmu.edu/~avrim/graphplan.html Avrim Blum's Graphplan home page]*[http://www.philippe-fournier-viger.com/plplan.html PLPLAN: A Java GraphPlan Implementation]*[http://nplanner.codeplex.com NPlanner: A .NET GraphPlan Implementation]*[http://emplan.sourceforge.net/ Emplan and JavaGP: C++ and Java implementations of Graphplan]
p341
sg17
I00
sg18
Nsg19
Nsbasg20
S''
sba(iversion
Version
p342
(dp343
g7
g8
(S'\x07\xde\x01\x1d\x16**\x00\x00\x00'
tRp344
sg10
VGraphplan is an algorithm for automated planning developed by Avrim Blum and Merrick Furst in 1995. Graphplan takes as input a planning problem expressed in STRIPS and produces, if one is possible, a sequence of operations for reaching a goal state. \u000aThe name graphplan is due to the use of a novel planning graph, to reduce the amount of search needed to find the solution from straightforward exploration of the state space graph.\u000aIn the state space graph:\u000a* the nodes are possible states,\u000a* and the edges indicate reachability through a certain action.\u000aOn the contrary, in Graphplan's planning graph:\u000a* the nodes are actions and atomic facts, arranged into alternate levels, \u000a* and the edges are of two kinds: \u000a*# from an atomic fact to the actions for which it is a condition, \u000a*# from an action to the atomic facts it makes true or false.\u000athe first level contains true atomic facts identifying the initial state. \u000aLists of incompatible facts that cannot be true at the same time and incompatible actions that cannot be executed together are also maintained.\u000aThe algorithm then iteratively extends the planning graph, proving that there are no solutions of length l-1 before looking for plans of length l by backward chaining: supposing the goals are true, Graphplan looks for the actions and previous states from which the goals can be reached, pruning as many of them as possible thanks to incompatibility information.\u000aA closely related approach to planning is the Planning as Satisfiability (Satplan). Both reduce the automated planning problem to search for plans of different fixed horizon lengths.\u000a*A. Blum and M. Furst (1997). Fast planning through planning graph analysis. Artificial intelligence. 90:281-300.\u000a*\u000a*[http://www.cs.cmu.edu/~avrim/graphplan.html Avrim Blum's Graphplan home page]\u000a*[http://www.philippe-fournier-viger.com/plplan.html PLPLAN: A Java GraphPlan Implementation]\u000a*[http://nplanner.codeplex.com NPlanner: A .NET GraphPlan Implementation]\u000a*[http://emplan.sourceforge.net/ Emplan and JavaGP: C++ and Java implementations of Graphplan]\u000a*[http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-825-techniques-in-artificial-intelligence-sma-5504-fall-2002/lecture-notes/Lecture12FinalPart1.pdf MIT OpenCourseWare lecture on GraphPlan and making planning graphs]\u000a
p345
sg12
(lp346
(iversion
Paragraph
p347
(dp348
g10
VGraphplan is an algorithm for automated planning developed by Avrim Blum and Merrick Furst in 1995. Graphplan takes as input a planning problem expressed in STRIPS and produces, if one is possible, a sequence of operations for reaching a goal state. The name graphplan is due to the use of a novel planning graph, to reduce the amount of search needed to find the solution from straightforward exploration of the state space graph.
p349
sg17
I00
sg18
Nsg19
Nsba(iversion
Paragraph
p350
(dp351
g10
VIn the state space graph:* the nodes are possible states,* and the edges indicate reachability through a certain action.
p352
sg17
I00
sg18
Nsg19
Nsba(iversion
Paragraph
p353
(dp354
g10
VOn the contrary, in Graphplan's planning graph:* the nodes are actions and atomic facts, arranged into alternate levels, * and the edges are of two kinds: *# from an atomic fact to the actions for which it is a condition, *# from an action to the atomic facts it makes true or false.
p355
sg17
I00
sg18
Nsg19
Nsba(iversion
Paragraph
p356
(dp357
g10
Vthe first level contains true atomic facts identifying the initial state. Lists of incompatible facts that cannot be true at the same time and incompatible actions that cannot be executed together are also maintained.
p358
sg17
I00
sg18
Nsg19
Nsba(iversion
Paragraph
p359
(dp360
g10
VThe algorithm then iteratively extends the planning graph, proving that there are no solutions of length l-1 before looking for plans of length l by backward chaining: supposing the goals are true, Graphplan looks for the actions and previous states from which the goals can be reached, pruning as many of them as possible thanks to incompatibility information.
p361
sg17
I00
sg18
Nsg19
Nsba(iversion
Paragraph
p362
(dp363
g10
VA closely related approach to planning is the Planning as Satisfiability (Satplan). Both reduce the automated planning problem to search for plans of different fixed horizon lengths.*A. Blum and M. Furst (1997). Fast planning through planning graph analysis. Artificial intelligence. 90:281-300.**[http://www.cs.cmu.edu/~avrim/graphplan.html Avrim Blum's Graphplan home page]*[http://www.philippe-fournier-viger.com/plplan.html PLPLAN: A Java GraphPlan Implementation]*[http://nplanner.codeplex.com NPlanner: A .NET GraphPlan Implementation]*[http://emplan.sourceforge.net/ Emplan and JavaGP: C++ and Java implementations of Graphplan]*[http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-825-techniques-in-artificial-intelligence-sma-5504-fall-2002/lecture-notes/Lecture12FinalPart1.pdf MIT OpenCourseWare lecture on GraphPlan and making planning graphs]
p364
sg17
I00
sg18
Nsg19
Nsbasg20
VEmausBot
p365
sbasS'title'
p366
VGraphplan
p367
sb.