\section{An Auction for Multi-Agent Pathfinding}
\label{sec:approach}

%This section describes my approach to representing and solving the MAPF problem with iterative combinatorial auctions. 
In the context of MAPF, we can use an the iBundle auction mechanism to allocate non-colliding paths to agents. Each item in the auction corresponds to a pair of grid location and time step, while bundles correspond to a set of locations and times which constitute a path. The auction begins with an ask price of $0$ assigned to all bundles (paths). It terminates when the provisional allocation includes all agents. 
We next describe how to model each component of the auction mechanism, focusing on the representation and computational challenges that arise in the pathfinding domain and how we solve them drawing on insights from both the pathfinding and auction literatures. 
%Finally, I describe the independence-detection framework~\cite{standley2010finding} which I used to decompose the auction to multiple, smaller auctions.

\subsection{Bidding on Paths}
In the MAPF domain we can assume that each agent has an infinite budget, and that units of this budget correspond to path cost units. I.e.. waiting for one time step corresponds to spending one budget unit. Agents' valuations for bundles, or paths, are relative -- if there is a path $A$ with cost $C$ and a path $B$ of cost $C+1$, an agent should be willing to pay up to one unit more on path $A$. However, there is no absolute limit to the amount the agent is willing to pay for a particular path.

Following a myopic best response bidding strategy~\cite{parkes1999bundle}, agents bid at each round on paths that minimize the sum of travel cost, denoted $c$ and the current price of the path, denoted $p$. For example, given the problem shown in Figure~\ref{fig:mapf}, in the first round of the auction $a_1$ would bid on its shortest path, that is $[<(0,1),t_1>,<(1,1),t_2>]$. $a_2$ would place a $XOR$ bid on its three shortest paths:$[<(0,2),t_1>,<(0,1),t_2,<(1,1),t_3,<(2,1),t_4>]$; $[<(0,2),t_1>,<(1,2),t_2,<(1,1),t_3,<(2,1),t_4>]$; $[<(0,2),t_1>,<(1,2),t_2,<(2,2),t_3,<(2,1),t_4>]$. Similarly, $a_3$ would bid on all of its shortest paths (paths with $c=4$). Note that if agents bid on paths that end at an earlier time than some other agent's paths, we extend their paths to match the longest paths by adding their last location to the next time steps\footnote{When agents reach their goals, they are assumed to stay there, such that other agents cannot occupy these locations.}.

As prices increase, agents begin to consider longer paths. Specifically, their best response should include all paths that reach the goal with a minimum value of $c+p$. For example, given that all paths with $c=3$ that $a_2$ can traverse to reach its goal are priced at 1 ($p=1$) and paths with $c=4$ are priced at 0, $a_2$ would bid on all paths with $c=3$ at price 1 and all paths with $c=4$ at price 0, as they have the same total cost ($c+p=4$). 

Importantly, there could be exponentially more paths for an agent at each cost. For example, the set of paths of cost 4 for agent $a_2$ includes waiting at each of the location in any of the paths of cost 3. As the auction progresses agents bid on paths of higher costs. This increase in the number of bundles (paths) agents bid on poses a representation problem as well as a computational difficulty for the winner determination problem (which is already computationally hard). To address these problems, we efficiently represent bids using multi-value decision diagrams (MDDs)~\cite{srinivasan1990algorithms} which were used in the ICTS algorithm to represent paths of different costs~\cite{sharon2012increasing}. 

An MDD for a single agent and a given cost represents all possible paths from the starting location of the agent to its goal at the defined cost. Figure~\ref{fig:mapf}(b) shows the MDD for agent $a_2$ with $c=3$. This MDD represents all of the paths that $a_2$ can take from its location to its goal, at a cost of 3. Each level of the MDD includes all of the locations that $a_2$ might be at in a specific time step when traversing a path of cost 3 to the goal. An edge connects an MDD node with locations in the next level that can be arrived at from the current location. For example, at level 1, $a_2$ could be at either location $(1,2)$ or $(0,1)$. From $(1,2)$ it can move to either $(1,1)$ or $(2,2)$, while from $(0,1)$ it can only move to $(1,1)$ in order to reach the goal in cost 3. Note that if there are $V$ vertices in the graph representing the grid, there can be at most $V \cdot C$ nodes in each level of an MDD of cost $C$. As explained above, we align the MDDs to have the same cost by replicating the goal node in the next time steps, as show for agent $a_1$ in Figure~\ref{fig:mapf}(c) (dashed nodes and edges were added to match the length of $a_2$'s MDD). Note that the cost used in the MDDs refers to the travel cost ($c$) and does not consider the prices of the paths in the auction.



\subsection{Winner Determination}
At the end of each round, a \emph{provisional allocation} is determined. The provisional allocation is chosen such that it maximizes revenue and includes non-conflicting paths for the set of agents included in the allocation. Ties are broken in favor of allocations that include more agents. The winner determination procedure requires costly computation: a naive approach would need to consider all possible combinations of paths that could be assigned to each subset of agents in the problem. For example, given the bids from the agents in the problem shown in Figure~\ref{fig:mapf}, the winner determination process needs to consider an allocation that includes all three agents (which requires considering every combination of the paths they bid on), the 3 combinations of two agents (again, considering all their possible paths combinations based on bids) and finally all allocations that include only one of the agents, one for each of its bids. 


At a high-level, the winner determination has the following components: (1) generating the possible allocations; (2) checking whether the allocation is feasible, and (3) compute the revenue of each allocation and choose the one that gives the highest revenue. In the pathfinding domain, checking whether an allocation is feasible requires solving a sub-problem of the complete pathfinding problem, namely searching for non-conflicting paths for the agents given their MDD. This problem requires significant computation, making the winner determination a particularly hard problem in the pathfinding context. 

Using MDDs, we reduce the complexity by solving save the need to consider every possible path separately. To check whether a candidate allocation is feasible, we use the algorithm used by Sharon et al.~\cite{sharon2012increasing} for solving an ICT node. 
%Their algorithm merges and prunes the MDDs and then checks if there exists a non-conflicting path to the agents' goal at the current cost \note{Ofra}{Guni/Roni, please see this is ok. Also I think we can shorten this and the following paragraphs significantly and just refer to the ICTS paper. agreed?}. 
Figure\ref{fig:mapf}(d) shows the resulting MDD of merging the MDDs for $a_1$ and $a_2$. In this merged MDD, each node includes two locations, one for each agent. While merging the MDDs, we delete nodes in which both agents occupy the same location. For example, the node marked in red in the figure will be deleted as both agents need to occupy location $(1,1)$. Paths that traverse through conflicting nodes are also deleted (shown in dashed lines in the figure). 

We can see that an allocation that includes $MDD^3_2$ and $MDD^1_1$ is valid, as there is one remaining path in the merged $MDD^{3,1}_{2,1}$ that gets both agents to their goals at the desired cost and without conflicting. This merging approach can be trivially extended to more than two agents, and a path on the merged MDD can be found using any search algorithm. Merging the MDDs is done using a matching and pruning algorithm from Sharon et al.~\cite{sharon2012increasing}. Merged MDDs are then solved using the $A^*$ algorithm with a pre-computed perfect heuristic for individual agents' paths.  Importantly, this search is performed on a small subset of the entire search space for the given agents as it only considered paths of a given cost. In addition, prior to the search, the merged MDD is pruned for illegal paths. 

In the example problem shown in Figure~\ref{fig:mapf}, the provisional allocation at the end of the first round will include one of the three possible pairs of agents. This is because there is no combination of the three agents' shortest paths that does not conflict. However, all pairs of MDDs are possible as they include at least one non-conflicting combination of paths and therefore one of these pairs will be chosen (recall ties are broken in favor of more agents, so there is no reason to include only one agent in the provisional allocation). This means that at the end of this iteration two agents will be included in the provisional allocation, while the third agent will remain ``unhappy''.  

%while $a_3$ will not be included because all of its shortest paths conflict with the other agents (although all prices are 0 and thus the revenue is equal for all possible allocations, we prefer allocations with more agents). Note that the allocation specifies the agents and their MDDs, without describing the specific non-conflicting paths.
 Interestingly, in typical auction applications the number of items is limited and can be decided by the auctioneer. In the pathfinding domain, because of the time dimension, the number of items is high. In addition, because agents have relative valuations, they submit many bids. In particular, they always keep bidding on paths that they bid on in previous rounds, whereas in typical auctions agents stop bidding on bundles when their price exceeds the agent's valuation of the bundle. 
 
 We implemented two different approaches to efficiently iterate candidate allocation. The first approach used a branch and bound algorithm in searching the space of possible allocations similar to that proposed by Sandholm~\cite{sandholm2002algorithm}. The second approach utilizes the structure in agents' bids. We note that at each round of the auction, all candidate allocations from previous rounds that were not found to be infeasible will remain candidate allocation in all future rounds. Their revenue increases according to the number of agents in the allocation that were ``unhappy'' in the last round. In addition, each agent that was unhappy in the last round submits a bid on one new MDD. This MDD can potentially be added to any allocation that does not yet include another MDD of the same agent, and also forms a new candidate with only that MDD. We thus maintain a sorted list of these candidate allocations and update it at each round based on the changes described above (making sure to place the new candidates in the appropriate location based on their revenue). Then, we iterate the list in decreasing order of revenue, checking whether the candidate allocation is feasible. If it is not feasible, we prune it (because there is no point to consider it in the future with additional MDDs) and move to the next candidate allocation. If the allocation is feasible, it is the winner of that round. Because the list is sorted by revenue, we do not have to keep solving the remaining candidates. \note{Ofra}{do we need a pseudo-code for this?}. We found this approach to be more efficient than branch and bound.  Yet, the winner determination stage of the algorithm remains a major computational bottleneck. 

%To further improve the efficiency of determining the provisional allocation, I use a branch and bound algorithm in searching the space of possible allocations similar to that proposed by Sandholm~\cite{sandholm2002algorithm}. That is, I maintain the highest revenue found so far, and prune allocations that cannot achieve a higher revenue without computing whether they are valid allocations. A priority queue is used where allocations are tested in order based on their potential revenue. As a first bound I use the revenue that is achieved from the winning allocation of the previous round (we know that agents will keep bidding on the paths in that allocation because their prices remained the same). Finally, a cache is used to store allocations that have been tried in previous and current iterations that specifies for each allocation whether it has a non-conflicting solution or not. This allows for further pruning of conflicting bids and their supersets. Yet, the winner determination stage of the algorithm remains a major computational bottleneck, as discussed in Section~\ref{sec:res}. The auction terminates when all agents are ``happy'', that is all agents are included in the provisional allocation. 

\subsection{Price Update}
As in the iBundle auction, at the end of each iteration we increase the prices for bundles (paths) that agents who were not included in the provisional allocation (``unhappy agents'') bid on. Since we know that if an agent bid on an MDD and did not receive it, all the paths in that MDD conflicted with other agents, we increase prices for MDDs, rather than for each path separately. The price is incremented by $\epsilon$ which is a parameter of the algorithm  \footnote{We assume that no two agents bid on the same bundles (MDDs) and are therefore not affected by changes in prices for bundles (MDDs) of other agents. This is a reasonable assumption as agents typically have different starting locations and goals. If it happened to be the case that a path of an agent is a subset of a path of another agent, then pricing of these paths can be viewed as discriminatory, where the price for each agent is determined according to the price of its MDD.}.

For example, recall that at the end of the first iteration of an auction for the problem from Figure~\ref{fig:mapf}, the provisional allocation includes two agents. Let us assume that $MDD^3_2$ and $MDD^1_1$ were arbitrarily chosen to be included in the provisional. Therefore, the price for the paths $a_3$ bid on, namely $MDD^4_3$, increases by $\epsilon$. Assuming $\epsilon=1$, this means that the price of $MDD^4_3$ is now 1, while the prices of  $MDD^3_2$ and $MDD^1_1$, as well as prices for any other MDDs that were not bid on yet, remain 0. 

%Thus, at the next iteration, $a_1$ and $a_2$ will continue bidding on the same MDDs. $a_3$ will now make a $XOR$ bid including both $MDD^4_3$ (travel cost + price = 4+1=5) and $MDD^5_3$ (travel cost + price = 0+5=5). Note that in the next iteration $a_3$ will surely be included in the provisional allocation, and in particular $MDD^4_3$ would be included in the allocation as it ensures a revenue of 1 while other allocations produce zero revenue. Since this MDD can be merged with either $MDD^1_1$ or $MDD^3_2$, one of these will be included in the provisional allocation together with $MDD^4_3$. Again we have a remaining ``unhappy'' agent at the end of the iteration, and the ask price for the MDD it bid on will increase to 1. This process continues until all agents are happy. 

The choice of $\epsilon$ in the auction affects the efficiency of the algorithm. Generally, as $\epsilon$ approaches $0$ the iBundle auction is known to terminate with an optimal (most efficient) allocation when agents bid according to myopic best response. However, decreasing the $\epsilon$ leads to more rounds of the auctions and thus sometimes a larger value is preferred in order to terminate earlier. 
Interestingly, due to the particular valuation function in MAPF, while increasing $\epsilon$ leads to fewer rounds, each round requires more computation in the winner determination stage. This is because when we increase the price of an MDD by a greater amount, the agent will bid on additional MDDs. For example, consider increasing the price of paths with travel cost 4 from 0 to 5. Now, the agent should bid on all paths that are withing $\epsilon$ of its best price and will thus bid on more MDDs (e.g. MDD of travel cost 5, 6, 7 and 8). This requires more computation at each iteration and therefore does not reduce complexity. 

%\subsection{The Independence-Detection Framework}
%The source of complexity in MAPF is the number of agents. Thus, decomposing a problem to multiple problems that include subsets of the agents has great potential for reducing the computational complexity of solving an MAPF problem instance. Following this idea, Standley~\cite{standley2010finding} proposed the independence-detection algorithm for MAPF. At the high-level, the algorithm finds independent sub-groups of agents that can be solved separately. At the low-level, it invokes any optimal search algorithm to solve sub-problems that include a subset of the agents. The general approach to finding independent groups of agents is as follows: initially, each agent is assigned to its own group. Then, when conflicts are detected, the agents' groups are merged and solved together. This process continues until there are no conflicts between the resulting groups. I use the independence-detection as the high-level algorithm, and the auction mechanism as the low-level search algorithm that solves the subproblems during the search process.

\subsection{Allocation Efficiency}
It has been proven that iBundle with myopic best response bids finds the optimal allocation as  $\epsilon \rightarrow 0$~\cite{parkes2006iterative}. In the pathfinding domain, settings $\epsilon = 1$ would result in the same bids as setting any $\epsilon \rightarrow 0$ because agents are indifferent between a path with $c=x$ and $p=y$ and a path with $c=x$ and $p=y-1$. Thus, using $\epsilon=1$ is sufficient for the auction to terminate with the optimal allocation with agents bidding their myopic best response at each iteration of the auction. 


%When agents bid their myopic best response and $\epsilon<=1$, the auction will terminate with the optimal allocation.
%That is, it will find the set of paths that have the minimal sum of time steps required by agents to reach their goals\footnote{the following analysis also assumes that no two agents bid on the same bundles (MDDs) and are not affected by price increases for other agents, as explained in the price update description.}. To see this is the case we can observe the following:
%Note that at the first round agents bid on their shortest paths (paths with travel cost $c_{min}$) at price $0$. If an agent is ``unhappy'' at the end of this first iteration, the price for its paths of travel cost $c_{min}$ will be raised to $0+\epsilon$. If $\epsilon=1$ this means that at the next round that agent will submit a $XOR$ bid including a bid on paths of travel cost $c_{min}$ at price $1$ and a bid on paths of travel cost $c_{min}+1$ at price $0$. In the next iteration when that agent is ``unhappy'', prices will be raised again -- $2$ for $c_{min}$ paths and $1$ for  $c_{min}+1$ paths. Given these prices, the agent will next bid on paths of cost $c_{min}$ at price $2$, paths of cost $c_{min}+1$ at price $1$ and paths of cost $c_{min}+2$ at price $0$. More generally, when $\epsilon<=1$, at any round an agent bids on all of its paths with $c_{path}<=c_{min}+n_{uh}\cdot\epsilon$, where n_{uh} denotes the number of iterations in which the agent was ``unhappy''.
%Importantly, the agent will never stop bidding on paths it previously submitted bids on because when $\epsilon<=1$ a previous path is always evaluated at least as good as any longer paths. Further, it will always submit higher bids on shorter paths (because their price would have been raised more times than the price of longer paths).
%
%We denote $\delta_{i}$ as the difference between the cost of agent $i$'s shortest path disregarding the other agent and the cost of its path in the final optimal allocation.  
%
%This property of bids alone is still insufficient to ensure an optimal allocation, because while every agent bids on all of its shorter paths at a higher cost, in principle it might still be the case that there would be an allocation with a lower total cost. For example, assume we have 3 agents, each has a shortest path of travel cost 1. If at the end of the iteration we raise the prices for two agents, they will start bidding on paths of travel cost 2 as well. This means that we will now check an allocation with costs of 2,2 and 1 (total of 5) before checking some allocations with cost 4, e.g. (1,2,1); (2,1,1); (1,1,2). However, this does not pose a problem in our auctions mechanism, because we know that if there was an allocation with total cost of 4, there had to be at least one pair of agents that did not conflict in their shortest paths and therefore they would have been included in the provisional allocation in the first iteration (due to tie-breaking in favor of more agents), and the price would have only been raised for one agent. That is, ``skipping'' options is guaranteed not to eliminate a non-conflict set of paths. More generally, because we break ties in favor of larger allocations and because agents always keep bidding on their shorter paths, and at higher prices compared to longer paths, combinations of shorter paths that do not conflict will result in higher revenue (as their prices are higher). Thus, these combinations will be preferred in the winner determination process over combinations of longer paths, and we will terminate with the optimal allocation.






%
%and $uh$ denote the number of rounds in which the agent was ``unhappy'' (not included in the provisional allocation). At any consequent round, an agent bids on all of its paths that have cost $C'<=C+uh\cdot\epsilon$. To see this, note that at the first round agents bid on their shortest paths (paths with travel cost $C$) at price $0$. If an agent is ``unhappy'' at the end of this first iteration, the price for its paths of travel cost $C$ will be raised to $0+\epsilon$. If $\epsilon=1$ this means that at the next round that agent will submit a $XOR$ bid including a bid on paths of travel cost $C$ at price $1$ and a bid on paths of travel cost $C+1$ at price $0$. In the next iteration when that agent is ``unhappy'', prices will rise again -- $2$ for cost $C$ paths and $1$ for cost $C+1$ paths. Given these prices the agent will next bid on paths of cost $C$ at price $2$, paths of cost $C+1$ at price $1$ and paths of cost $C+2$ at price $0$. Importantly, because $\epsilon<=1$, it will never stop bidding on paths it previously submitted bids on. Furthermore, note that the prices for higher travel cost paths are always lower than prices for lower travel cost paths. This is because agents first bid on shorter paths and keep bidding on them such that whenever a price is raised for a longer path it is also raised for the shorter paths. 

%\begin{itemize}
%\item At the first round, all agents bid on all of their shortest paths, at cost $0$. 
%\item Let $C$ denote the travel cost of the shortest path for an agent and $uh$ denote the number of rounds in which the agent was ``unhappy'' (not included in the provisional allocation). At any consequent round, an agent bids on all of its paths that have cost $C'<=C+uh\cdot\epsilon$. This is because the prices for lower travel cost paths are increased according to the number of rounds in which the agent bid on them and was unhappy. Because the price is increased by at most 1 at each iteration, the agents should keep bidding on their shortest paths, as explained next.
%\item The prices for higher travel cost paths are always lower than prices for lower travel cost paths. In particular, if $\epsilon=1$, the difference in price is exactly the negative of the difference in travel cost. This is because an agent starts bidding on a path only when the cost for lower travel cost paths increases. For example, in the first round an agent bids on its shortest path that has travel cost $C$. With $\epsilon=1$, if the agent was unhappy, the price for these paths will increase and in the next round the agent will bid on paths of travel cost $C$ at price 1 and paths of travel cost $C+1$ at price $0$. Similarly, if it is still unhappy, price for $C$ paths increases to $2$ while price for $C+1$ paths increases to $1$. Now the agent will also bid on paths of cost $C+2$ at price $0$. 
%\end{itemize}

%Given these properties, we can see that if an allocation that includes all agents was chosen as the provisional allocation at round $t$, there cannot be another allocation with a lower total cost for all agents. We know that all agents keep bidding on their lower travel cost paths at each round, and at a higher price. Thus, if there was an allocation with a lower cost, the paths included in it would be priced higher and it would have been chosen as the provisional allocation as it would result in higher revenue. 