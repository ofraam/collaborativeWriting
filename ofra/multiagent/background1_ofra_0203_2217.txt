\section{Background}
\label{sec:bg}
\note{Ofra}{This is from my project. Please improve and shorten. Possibly move to introduction.}
This section presents the MAPF problem and the iBundle auction mechanism that we use to solve MAPF. We also describe the increasing cost tree search (ICTS) algorithm as we use techniques implemented in ICTS in our auction implementation. We also compare the auction mechanism with ICTS, discussing their similarities and differences.

\subsection{The Multi-Agent Pathfinding Problem}
\label{sec:problemDef}
\note{Ofra}{can we move the problem definition to the introduction and shorten it significantly?}
 MAPF address the problem of finding non-conflicting paths for a set of agents located on a graph~\footnote{I define the problem for grids, but any graph which agents can traverse can be used.}. MAPF has been shown to be NP-Complete~\cite{surynek2010optimization} Formally, an MAPF problem is defined by: 
\begin{itemize}
\item A set of agents ${a_1,...,a_n}$.
\item A set of starting locations ${s_1,...,s_n}$, where $s_i$ is the starting location of agent $a_i$.
\item A set of goal locations ${g_1,...,g_n}$, where $g_i$ is the starting location of agent $a_i$.
\end{itemize}
At any time $t$, an agent can occupy a single location $l$ on the grid. When an agent moves to an adjacent square at time $t$ it will occupy the destination square at time $t+1$. It is typically assumed that only one agent can occupy a specific location at any given time. Thus, a solution to an MAPF problem needs to assign a path to each agent such that: (1) the agent reaches its goal, and (2) agents do not collide. It is assumed that agents have full knowledge of the map and that when an agent reaches its goal it remains at that location (and no other agent can occupy it). We aim to find \emph{efficient} solutions, that is solutions minimize the total cost of the paths traversed by agents (i.e. minimizing the sum of time steps required for agents to reach their goals).

%For example, consider the grid in Figure~\ref{fig:mapf}. $a_1$'s starting location is $(0,1)$ and its goal is located at square $(1,1)$, while $a_2$'s starting location is $(0,2)$ and its goal is located at $(2,1)$. $a_3$ starts at $(1,3)$ and needs to reach $(2,0)$. If each of the agents $a_1$, $a_2$ and $a_3$ were alone on the grid, their shortest paths would be of cost 1, 2 and 4 respectively. However, no combination of their shortest paths does not collide, therefore at least one agent has to wait. The optimal solution in this case has a total cost of 8, rather than 7 which is the sum of the shortest individual paths (one possibility is for $a_2$ to wait one turn).


\begin{figure}
\centering
\includegraphics[width = 6cm]{figs/gridMddsCropped.pdf}
\caption{An example MAPF problem with 3 agents and MDDs. (a) the grid describing the problems. Mice are the agents, and each agent's goal is the location of the cheese with the same index; (b) An MDD representing the paths of agent $a_2$ that reach the goal with cost 3; (c) An MDD representing the paths of agent $a_1$ that reach the goal with cost 1 (extended with dashed nodes to align with the size of the MDD of agent $a_2$); (d) The joint MDD of $a_1$ and $a_2$. The red node represents a conflict and will be removed from the MDD together with paths passing through it (dashed lines). }
\label{fig:mapf}
\end{figure}

\subsection{The iBundle Iterative Combinatorial Auction}
\note{Ofra}{do we need an example of an auction or is this enough?}
In combinatorial auctions, the auctioneer has items for sale, as in a regular auction. However, agents may bid on \emph{bundles} of items, that is a set of items they wish to buy. Similarly, prices are assigned to bundles rather than individual items, supporting non-linear pricing of bundles.

% For example, assume an auctioneer wishes to sell a winter jacket, boots and hat. Bidders may bid on different bundles (e.g. jacket and boots for \$10,  boots and hat for \$5). In particular, they can submit $XOR$ bids that specify a set of bundles of which they would only want to buy one. Bundle prices are determined by the demand of the bundle and do not have to align with the sum of prices of individual items in the bundle. For example, a bundle that includes only jacket may be priced at \$3 and a bundle that includes only the hat at \$4, while a bundle including both the jacket and the hat could be priced at \$12. Note, however, that a bundle that is a super-set of another bundle cannot be priced lower than its subset (e.g. the jacket, hat and boots cannot be priced at less than \$12).

In iterative combinatorial auctions (ICA), the auction has multiple rounds (iterations). At each iteration, agents submit bids and the auctioneer updates prices, until the auction terminates. Iterative auctions require less effort from agents as they do not need to express their entire  preferences. We used the iBundle~\cite{parkes2001iterative} ICA mechanism to solve the MAPF problem. 

In iBundle, each iteration includes three stages: (1) bidding; (2) winner determination, and (3) price update. 
In the bidding stage, agents bid on bundles based on the current ask prices. Agents can submit $XOR$ bids, that is bid on alternative bundles that they desire but stating that they wish to receive at most one of those bundles.
%It has been shown that if agents bid their \emph{myopic best response}, that is they bid on the bundles that maximize their value given the current ask prices, the auction is truthful~\cite{parkes2001iterative}. 
In the winner determination process, the auctioneer determines a provisional allocation that maximizes revenue based on the current bids. An item can only be included in one bundle in the provisional allocation (that is, we cannot assign the same item to two different agents). Finally, prices are updates as follows: for each bundle that an ``unhappy'' agent (i.e. an agent that did not receive any of its bundles in the provisional allocation) bid on, the price is raised to the maximum bid received on the bundle by an unhappy agent plus $\epsilon$, where $\epsilon$ is the minimal increment size in the auction. Intuitively, this means that prices for bundles that include items with higher demand are raised as the auction progresses. This might cause the agent who bid on them to switch to other bundles, or alternatively, if agents have a high valuation for a bundle they will keep bidding on it despite the higher prices, leading other agents to ``lose'' update their bids. The auction terminates when the provisional allocation includes all of the agents, or when the same bids are submitted in two consequent rounds. In the approach section we describe how iBundle can be implemented to solve MAPF problems.

\subsection{The Increasing Cost Tree Search}
The ICTS algorithm~\cite{sharon2012increasing} consists of two levels. At the high-level, the search is performed on cost nodes that specify for each agent the cost of its paths to the goal that are considered in the current ICT node.
% At the low-level, the algorithm performs a ``goal test'' on each expanded ICT node. This goal test searches for a feasible solution for a specific ICT node and returns true if there is a non-conflicting set of paths for all agents.
The search starts from an ICT node with costs corresponding to the shortest paths costs for each of the agents ignoring the other agents. Then, nodes are expanded in a breadth-first manner, where each layer includes nodes with a specific sum of costs. Every time a node is expanded, the low-level search performs a goal test on the ICT node, checking whether there is a non-conflicting set of paths for the agents with the required costs. If the goal test passes, the algorithm terminates. If it does not, new ICT nodes are generated -- where each child node increases the cost for one of the agents, resulting in a total cost great by 1 then its parent node.

For example, if the initial costs were 3,5 and 6 and a non-conflicting solution did not exist at these costs, three ICT child nodes will be generated, with  costs of ${4,5,6}$; ${3,6,6}$, and ${3,5,7}$. Because the ICT is searched in a breadth-first manner, an optimal solution is guaranteed (a node with a lower sum of costs will always be searched before nodes with higher sum of costs). 

To efficiently solve ICT nodes (i.e., perform a goal test), the low-level search uses multi-value decision diagrams (MDDs)~\cite{srinivasan1990algorithms}. An MDD for a single agent and a given cost represents all possible paths from the starting location of the agent to its goal at the defined cost. Figure~\ref{fig:mapf}(b) shows the MDD for agent $a_2$ with $c=3$. This MDD represents all of the paths that $a_2$ can take from its location to its goal, at a cost of 3. Each level of the MDD includes all of the locations that $a_2$ might be at in a specific time step when traversing a path of cost 3 to the goal. An edge connects an MDD node with locations in the next level that can be arrived at from the current location. For example, at level 1, $a_2$ could be at either location $(1,2)$ or $(0,1)$. From $(1,2)$ it can move to either $(1,1)$ or $(2,2)$, while from $(0,1)$ it can only move to $(1,1)$ in order to reach the goal in cost 3. Note that if there are $V$ vertices in the graph representing the grid, there can be at most $V \cdot C$ nodes in each level of an MDD of cost $C$. As explained above, we align the MDDs to have the same cost by replicating the goal node in the next time steps, as show for agent $a_1$ in Figure~\ref{fig:mapf}(c) (dashed nodes and edges were added to match the length of $a_2$'s MDD). 